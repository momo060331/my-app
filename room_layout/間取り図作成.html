<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>é–“å–ã‚Šå›³ä½œæˆã‚¢ãƒ—ãƒª</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: 'Segoe UI', sans-serif; display: flex; height: 100vh; background: #f5f5f5; }
        #sidebar { width: 280px; background: white; box-shadow: 2px 0 5px rgba(0,0,0,0.1); padding: 20px; overflow-y: auto; }
        h1 { font-size: 20px; margin-bottom: 10px; color: #333; }
        .total-area-display { background: #4caf50; color: white; padding: 12px; border-radius: 4px; margin-bottom: 20px; font-size: 16px; font-weight: bold; text-align: center; }
        .section { margin-bottom: 20px; }
        .section-title { font-size: 14px; font-weight: bold; margin-bottom: 10px; color: #555; }
        button { width: 100%; padding: 10px; margin-bottom: 8px; border: none; border-radius: 4px; cursor: pointer; font-size: 13px; transition: all 0.2s; }
        button:hover { opacity: 0.9; }
        .tool-btn { background: #e0e0e0; color: #333; }
        .tool-btn.active { background: #2196f3; color: white; }
        .action-btn { background: #4caf50; color: white; }
        .danger-btn { background: #f44336; color: white; }
        .info-btn { background: #ff9800; color: white; }
        input, select { width: 100%; padding: 8px; margin-bottom: 10px; border: 1px solid #ddd; border-radius: 4px; font-size: 13px; }
        label { display: block; font-size: 12px; color: #666; margin-bottom: 4px; }
        #canvas-container { flex: 1; padding: 20px; overflow: auto; }
        canvas { background: white; box-shadow: 0 2px 10px rgba(0,0,0,0.1); cursor: crosshair; border-radius: 4px; }
        .selected-info { background: #e3f2fd; padding: 15px; border-radius: 4px; margin-bottom: 15px; }
        .info-box { background: #f5f5f5; padding: 12px; border-radius: 4px; font-size: 13px; }
        .info-box p { margin: 5px 0; }
        .btn-group { display: flex; gap: 8px; }
        .btn-group button { flex: 1; margin-bottom: 8px; }
        .color-picker { height: 40px; cursor: pointer; }
        .hint { background: #fff3cd; padding: 8px; border-radius: 4px; font-size: 11px; color: #856404; margin-top: 8px; }
        .total-area-display button {
            background: #4caf50 !important;
        }
        /* ãƒ¢ãƒã‚¤ãƒ«å¯¾å¿œ */
        @media (max-width: 768px) {
            body { flex-direction: column; }
            #sidebar {
                width: 100%;
                max-height: 40vh;
                overflow-y: auto;
                padding: 10px;
            }
            h1 { font-size: 16px; margin-bottom: 10px; }
            .total-area-display { 
                font-size: 11px !important; 
                padding: 6px !important; 
                margin-bottom: 10px; 
            }
            .total-area-display button {
                font-size: 11px !important;
                padding: 4px 6px !important;
                min-width: 28px !important;
                background: #4caf50 !important;
            }
            .section { margin-bottom: 10px; }
            .section-title { font-size: 12px; }
            button { padding: 8px; font-size: 12px; margin-bottom: 4px; }
            input { padding: 6px; font-size: 12px; }
            label { font-size: 11px; }
            #canvas-container { padding: 10px; flex: 1; }
            canvas { width: 100%; height: auto; max-width: 100%; }
            .hint { font-size: 10px; padding: 6px; }
        }
        
        /* ã‚¿ãƒƒãƒæ“ä½œç”¨ */
        canvas { touch-action: none; }
        button { -webkit-tap-highlight-color: transparent; }
    </style>
</head>
<body>
    <div id="sidebar">
        <h1>ğŸ  é–“å–ã‚Šå›³ä½œæˆ</h1>
        <div class="total-area-display" style="display: flex; align-items: center; justify-content: center; gap: 6px; flex-wrap: nowrap;">
            <button class="info-btn" id="undoBtn" disabled style="padding: 6px 10px; margin: 0; font-size: 14px; min-width: 36px;">â®ï¸</button>
            <span style="white-space: nowrap;">ç·é¢ç©: <span id="totalAreaTop">0.0</span> ç•³</span>
            <button class="info-btn" id="redoBtn" disabled style="padding: 6px 10px; margin: 0; font-size: 14px; min-width: 36px;">â­ï¸</button>
        </div>
        
        <div class="section">
            <div class="section-title">ãƒ„ãƒ¼ãƒ«é¸æŠ</div>
            <button class="tool-btn active" data-tool="select">âœ‹ é¸æŠãƒ»ç§»å‹•</button>
            <button class="tool-btn" data-tool="room">ğŸ  éƒ¨å±‹è¿½åŠ </button>
            <div class="btn-group">
                <button class="tool-btn" data-tool="edit-vertex">ğŸ“ ç·¨é›†</button>
                <button class="tool-btn" data-tool="add-vertex">â• è¿½åŠ </button>
                <button class="tool-btn" data-tool="edit-edge">ğŸ“ è¾º</button>
            </div>
            <button class="tool-btn" data-tool="wall">ğŸ§± å£è¿½åŠ </button>
            <div class="btn-group">
                <button class="tool-btn" data-tool="door-swing">ğŸšªé–‹</button>
                <button class="tool-btn" data-tool="door-sliding">ğŸšªå¼•</button>
                <button class="tool-btn" data-tool="window">ğŸªŸçª“</button>
            </div>
            <button class="tool-btn" data-tool="manikin">ğŸš¶ äººå‹</button>
            <div class="hint">ğŸ’¡ å£è¿½åŠ : é ‚ç‚¹2ã¤ã‚¯ãƒªãƒƒã‚¯<br>ğŸ’¡ è¾ºç§»å‹•: æ³•ç·šæ–¹å‘ã®ã¿<br>ğŸ’¡ ãƒ‘ãƒ³: å³ã‚¯ãƒªãƒƒã‚¯ or Ctrl+ã‚¯ãƒªãƒƒã‚¯</div>
        </div>

        <div class="section">
            <div class="section-title">æ•·åœ°è¨­å®š</div>
            <label>æ•·åœ°ã®å¹… (m)</label>
            <input type="number" id="landWidth" value="10.1" min="5" max="100" step="0.1">
            <label>æ•·åœ°ã®å¥¥è¡Œã (m)</label>
            <input type="number" id="landDepth" value="10" min="5" max="100" step="0.1">
            <button class="action-btn" id="setLandBtn">æ•·åœ°ç¯„å›²ã‚’è¡¨ç¤º</button>
            <button class="info-btn" id="clearLandBtn" style="margin-top:4px;">æ•·åœ°ç¯„å›²ã‚’æ¶ˆå»</button>
        </div>
        
        <div class="section">
            <div class="section-title">è¡¨ç¤ºè¨­å®š</div>
            <label>æ‹¡å¤§ç¸®å° (<span id="scaleDisplay">100</span>%)</label>
            <div class="btn-group">
                <button class="info-btn" id="zoomOut">ğŸ”âˆ’</button>
                <button class="info-btn" id="zoomReset">100%</button>
                <button class="info-btn" id="zoomIn">ğŸ”+</button>
            </div>
            <button class="tool-btn" id="toggleGrid" style="margin-top:8px;">ğŸ“ ã‚°ãƒªãƒƒãƒ‰: ON</button>
            <button class="info-btn" id="resetPan" style="margin-top:4px;">ğŸ¯ è¡¨ç¤ºãƒªã‚»ãƒƒãƒˆ</button>
        </div>
        
        <div class="section">
            <div class="section-title">åŸºæœ¬è¨­å®š</div>
            <label>å£ã®åšã• (cm)</label>
            <input type="number" id="wallThickness" value="12" min="5" max="30">
            <label>ã‚°ãƒªãƒƒãƒ‰åˆ»ã¿ (cm)</label>
            <input type="number" id="gridSize" value="45" min="5" max="200" step="5">
        </div>

        <div id="selectedPanel" style="display:none;">
            <div class="section selected-info">
                <div class="section-title">é¸æŠä¸­</div>
                <div id="selectedType"></div>
                <div id="selectedControls"></div>
                <div class="btn-group" style="margin-top:10px;">
                    <button class="info-btn" id="rotateBtn">ğŸ”„</button>
                    <button class="danger-btn" id="deleteBtn">ğŸ—‘ï¸</button>
                </div>
            </div>
        </div>

        <div class="section">
            <div class="section-title">é¢ç©æƒ…å ±</div>
            <div class="info-box">
                <p><strong>ç·é¢ç©:</strong> <span id="totalArea">0.0</span> ç•³</p>
                <p><strong>éƒ¨å±‹æ•°:</strong> <span id="roomCount">0</span></p>
            </div>
        </div>

        <div class="section">
            <button class="action-btn" id="saveBtn">ğŸ’¾ ä¿å­˜</button>
            <button class="action-btn" id="loadBtn">ğŸ“‚ èª­è¾¼</button>
            <button class="action-btn" id="exportBtn">ğŸ“¥ ç”»åƒ</button>
            <button class="danger-btn" id="clearBtn">ğŸ—‘ï¸ ã‚¯ãƒªã‚¢</button>
        </div>
    </div>

    <div id="canvas-container">
        <canvas id="canvas" width="1400" height="1000"></canvas>
    </div>
    <input type="file" id="fileInput" style="display:none;" accept=".json">

    <script>
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');

let state = {
    rooms: [], walls: [], doors: [], windows: [], manikins: [],
    history: [],        // å±¥æ­´
    historyIndex: -1,   // å±¥æ­´ã®ç¾åœ¨ä½ç½®
    landBoundary: null, // æ•·åœ°ç¯„å›²
    selectedTool: 'select', selectedItem: null, selectedVertex: null, selectedEdge: null,
    isDragging: false, dragStart: null, dragOffset: null,
    wallThickness: 15, gridSize: 45, showGrid: true, scale: 50, zoomLevel: 1.5,
    wallStartVertex: null, tempWallEndPos: null, edgeNormal: null,
    isPanning: false, panOffset: { x: 0, y: 0 }  // ãƒ‘ãƒ³æ©Ÿèƒ½ç”¨
};

//ãƒ‰ã‚¢ãƒ»çª“ã‚’å£ã®è¾ºã«é…ç½®ã™ã‚‹é–¢æ•°
function findNearestEdge(x, y, threshold = 20) {
    let nearest = null;
    let minDist = threshold / state.zoomLevel;
    
    state.rooms.forEach(r => {
        for (let i = 0; i < r.vertices.length; i++) {
            const j = (i + 1) % r.vertices.length;
            const v1 = r.vertices[i];
            const v2 = r.vertices[j];
            const dist = distanceToSegment(x, y, v1.x, v1.y, v2.x, v2.y);
            
            if (dist < minDist) {
                minDist = dist;
                // è¾ºä¸Šã®æœ€è¿‘æ¥ç‚¹ã‚’è¨ˆç®—
                const dx = v2.x - v1.x;
                const dy = v2.y - v1.y;
                const l2 = dx * dx + dy * dy;
                let t = ((x - v1.x) * dx + (y - v1.y) * dy) / l2;
                t = Math.max(0, Math.min(1, t));
                
                const px = v1.x + t * dx;
                const py = v1.y + t * dy;
                const angle = Math.atan2(dy, dx) * 180 / Math.PI;
                
                nearest = {
                    roomId: r.id,
                    edgeIndex: i,
                    x: px,
                    y: py,
                    angle: angle,
                    t: t,  // è¾ºä¸Šã®ä½ç½® (0-1)
                    v1: v1,
                    v2: v2
                };
            }
        }
    });
    
    return nearest;
}

// å±¥æ­´ã«çŠ¶æ…‹ã‚’ä¿å­˜
function saveHistory() {
    // ã‚„ã‚Šç›´ã—ç”¨ã®å±¥æ­´ã‚’ã‚¯ãƒªã‚¢
    state.history = state.history.slice(0, state.historyIndex + 1);
    const snapshot = {
        rooms: JSON.parse(JSON.stringify(state.rooms)),
        walls: JSON.parse(JSON.stringify(state.walls)),
        doors: JSON.parse(JSON.stringify(state.doors)),
        windows: JSON.parse(JSON.stringify(state.windows)),
        manikins: JSON.parse(JSON.stringify(state.manikins)),
        landBoundary: state.landBoundary ? JSON.parse(JSON.stringify(state.landBoundary)) : null
    };
    state.history.push(snapshot);
    state.historyIndex++;
    if (state.history.length > 20) {
        state.history.shift();
        state.historyIndex--;
    }
    updateUndoRedoButtons();
}

function undo() {
    if (state.historyIndex > 0) {
        state.historyIndex--;
        const snapshot = state.history[state.historyIndex];
        state.rooms = JSON.parse(JSON.stringify(snapshot.rooms));
        state.walls = JSON.parse(JSON.stringify(snapshot.walls));
        state.doors = JSON.parse(JSON.stringify(snapshot.doors));
        state.windows = JSON.parse(JSON.stringify(snapshot.windows));
        state.manikins = JSON.parse(JSON.stringify(snapshot.manikins));
        state.landBoundary = snapshot.landBoundary ? JSON.parse(JSON.stringify(snapshot.landBoundary)) : null;
        state.selectedItem = null;
        state.selectedVertex = null;
        state.selectedEdge = null;
        updateUndoRedoButtons();
        draw();
    }
}

function redo() {
    if (state.historyIndex < state.history.length - 1) {
        state.historyIndex++;
        const snapshot = state.history[state.historyIndex];
        state.rooms = JSON.parse(JSON.stringify(snapshot.rooms));
        state.walls = JSON.parse(JSON.stringify(snapshot.walls));
        state.doors = JSON.parse(JSON.stringify(snapshot.doors));
        state.windows = JSON.parse(JSON.stringify(snapshot.windows));
        state.manikins = JSON.parse(JSON.stringify(snapshot.manikins));
        state.landBoundary = snapshot.landBoundary ? JSON.parse(JSON.stringify(snapshot.landBoundary)) : null;
        state.selectedItem = null;
        state.selectedVertex = null;
        state.selectedEdge = null;
        updateUndoRedoButtons();
        draw();
    }
}

function updateUndoRedoButtons() {
    const undoBtn = document.getElementById('undoBtn');
    const redoBtn = document.getElementById('redoBtn');
    
    undoBtn.disabled = state.historyIndex <= 0;
    undoBtn.style.opacity = state.historyIndex <= 0 ? '0.5' : '1';
    
    redoBtn.disabled = state.historyIndex >= state.history.length - 1;
    redoBtn.style.opacity = state.historyIndex >= state.history.length - 1 ? '0.5' : '1';
}

function switchToSelectTool() {
    state.selectedTool = 'select';
    document.querySelectorAll('.tool-btn[data-tool]').forEach(btn => btn.classList.remove('active'));
    document.querySelector('.tool-btn[data-tool="select"]').classList.add('active');
    canvas.style.cursor = 'default';
}

function snapToGrid(v) { const g = state.gridSize * 0.2; return Math.round(v / g) * g; }
function snapPointToGrid(p) { return { x: snapToGrid(p.x), y: snapToGrid(p.y) }; }
function calculatePolygonArea(vs) {
    let a = 0;
    for (let i = 0; i < vs.length; i++) {
        const j = (i + 1) % vs.length;
        a += vs[i].x * vs[j].y - vs[j].x * vs[i].y;
    }
    return Math.abs(a / 2);
}
function calculateTatamiFromArea(pa) { return ((pa / (state.scale * state.scale)) / 1.62).toFixed(1); }
function getTotalArea() {
    return (state.rooms.reduce((s, r) => s + calculatePolygonArea(r.vertices) / (state.scale * state.scale), 0) / 1.62).toFixed(1);
}
function getAllVertices() {
    const vs = [];
    state.rooms.forEach(r => r.vertices.forEach(v => vs.push({ x: v.x, y: v.y, roomId: r.id })));
    return vs;
}
function findNearestVertex(x, y, t = 15) {
    const vs = getAllVertices();
    let n = null, md = t / state.zoomLevel;
    vs.forEach(v => {
        const d = Math.sqrt((x - v.x) ** 2 + (y - v.y) ** 2);
        if (d < md) { md = d; n = v; }
    });
    return n;
}
function calculateDistance(x1, y1, x2, y2) { return Math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2); }
function formatLength(px) {
    const cm = px / state.scale * 100;
    return cm >= 100 ? (cm / 100).toFixed(2) + 'm' : Math.round(cm) + 'cm';
}
function getPolygonCenter(vs) {
    const s = vs.reduce((a, v) => ({ x: a.x + v.x, y: a.y + v.y }), { x: 0, y: 0 });
    return { x: s.x / vs.length, y: s.y / vs.length };
}
function isPointInPolygon(p, vs) {
    let inside = false;
    for (let i = 0, j = vs.length - 1; i < vs.length; j = i++) {
        const xi = vs[i].x, yi = vs[i].y, xj = vs[j].x, yj = vs[j].y;
        if (((yi > p.y) !== (yj > p.y)) && (p.x < (xj - xi) * (p.y - yi) / (yj - yi) + xi)) inside = !inside;
    }
    return inside;
}
function distanceToSegment(px, py, x1, y1, x2, y2) {
    const dx = x2 - x1, dy = y2 - y1, l2 = dx * dx + dy * dy;
    if (l2 === 0) return Math.sqrt((px - x1) ** 2 + (py - y1) ** 2);
    let t = ((px - x1) * dx + (py - y1) * dy) / l2;
    t = Math.max(0, Math.min(1, t));
    const nx = x1 + t * dx, ny = y1 + t * dy;
    return Math.sqrt((px - nx) ** 2 + (py - ny) ** 2);
}
function getEdgeMidpoint(v1, v2) { return { x: (v1.x + v2.x) / 2, y: (v1.y + v2.y) / 2 }; }

// ã‚­ãƒ£ãƒ³ãƒã‚¹ã‚µã‚¤ã‚ºã®èª¿æ•´
function resizeCanvas() {
    const container = document.getElementById('canvas-container');
    const rect = container.getBoundingClientRect();
    if (window.innerWidth <= 768) {
        canvas.width = rect.width - 20;
        canvas.height = rect.height - 20;
    } else {
        canvas.width = 1400;
        canvas.height = 1000;
    }
    draw();
}

window.addEventListener('resize', resizeCanvas);
window.addEventListener('load', resizeCanvas);

function draw() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    ctx.save();
    ctx.translate(state.panOffset.x, state.panOffset.y);
    ctx.scale(state.zoomLevel, state.zoomLevel);

    if (state.showGrid) {
        ctx.strokeStyle = '#e0e0e0';
        ctx.lineWidth = 0.5 / state.zoomLevel;
        const g = state.gridSize * 0.2;
        for (let x = 0; x < canvas.width / state.zoomLevel; x += g) {
            ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, canvas.height / state.zoomLevel); ctx.stroke();
        }
        for (let y = 0; y < canvas.height / state.zoomLevel; y += g) {
            ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(canvas.width / state.zoomLevel, y); ctx.stroke();
        }
    }

    // æ•·åœ°ç¯„å›²ã®æç”»
    if (state.landBoundary) {
        ctx.strokeStyle = '#ff5722';
        ctx.lineWidth = 3 / state.zoomLevel;
        ctx.setLineDash([10 / state.zoomLevel, 5 / state.zoomLevel]);
        ctx.strokeRect(
            state.landBoundary.x,
            state.landBoundary.y,
            state.landBoundary.width,
            state.landBoundary.height
        );
        ctx.setLineDash([]);
        
        // ã‚µã‚¤ã‚ºè¡¨ç¤º
        ctx.fillStyle = '#ff5722';
        ctx.font = `bold ${14 / state.zoomLevel}px sans-serif`;
        ctx.textAlign = 'center';
        ctx.fillText(
            `${(state.landBoundary.width / state.scale).toFixed(1)}m Ã— ${(state.landBoundary.height / state.scale).toFixed(1)}m`,
            state.landBoundary.x + state.landBoundary.width / 2,
            state.landBoundary.y - 10 / state.zoomLevel
        );
    }

    state.rooms.forEach(r => {
        const sel = state.selectedItem?.id === r.id;
        ctx.fillStyle = r.color || '#e3f2fd';
        ctx.beginPath();
        ctx.moveTo(r.vertices[0].x, r.vertices[0].y);
        for (let i = 1; i < r.vertices.length; i++) ctx.lineTo(r.vertices[i].x, r.vertices[i].y);
        ctx.closePath();
        ctx.fill();
        
        ctx.strokeStyle = sel ? '#2196f3' : '#666';
        ctx.lineWidth = (sel ? 3 : 1) / state.zoomLevel;
        ctx.stroke();

        r.vertices.forEach((v, idx) => {
            const sv = state.selectedVertex?.roomId === r.id && state.selectedVertex?.index === idx;
            ctx.fillStyle = sv ? '#f44336' : '#2196f3';
            const h = 8 / state.zoomLevel;
            ctx.fillRect(v.x - h/2, v.y - h/2, h, h);
        });

        if ((state.selectedTool === 'add-vertex' || state.selectedTool === 'edit-edge') && sel) {
            for (let i = 0; i < r.vertices.length; i++) {
                const j = (i + 1) % r.vertices.length;
                const se = state.selectedEdge?.roomId === r.id && state.selectedEdge?.index === i;
                ctx.strokeStyle = se ? '#f44336' : '#ff9800';
                ctx.lineWidth = 3 / state.zoomLevel;
                ctx.setLineDash([5 / state.zoomLevel, 5 / state.zoomLevel]);
                ctx.beginPath();
                ctx.moveTo(r.vertices[i].x, r.vertices[i].y);
                ctx.lineTo(r.vertices[j].x, r.vertices[j].y);
                ctx.stroke();
                
                if (state.selectedTool === 'edit-edge') {
                    const m = getEdgeMidpoint(r.vertices[i], r.vertices[j]);
                    ctx.fillStyle = se ? '#f44336' : '#ff9800';
                    const h = 10 / state.zoomLevel;
                    ctx.fillRect(m.x - h/2, m.y - h/2, h, h);
                }
            }
            ctx.setLineDash([]);
        }

        const c = getPolygonCenter(r.vertices);
        ctx.fillStyle = '#333';
        ctx.font = `bold ${16 / state.zoomLevel}px sans-serif`;
        ctx.textAlign = 'center';
        ctx.fillText(r.name || 'éƒ¨å±‹', c.x, c.y - 15 / state.zoomLevel);
        ctx.font = `${14 / state.zoomLevel}px sans-serif`;
        ctx.fillText(calculateTatamiFromArea(calculatePolygonArea(r.vertices)) + 'ç•³', c.x, c.y + 5 / state.zoomLevel);
        if (r.purpose) {
            ctx.font = `${12 / state.zoomLevel}px sans-serif`;
            ctx.fillStyle = '#666';
            ctx.fillText(r.purpose, c.x, c.y + 22 / state.zoomLevel);
        }
    });

    state.walls.forEach(w => {
        const sel = state.selectedItem?.id === w.id;
        ctx.strokeStyle = sel ? '#2196f3' : '#333';
        ctx.lineWidth = w.thickness / state.zoomLevel;
        ctx.lineCap = 'square';
        ctx.beginPath();
        ctx.moveTo(w.x1, w.y1);
        ctx.lineTo(w.x2, w.y2);
        ctx.stroke();
        
        const mx = (w.x1 + w.x2) / 2, my = (w.y1 + w.y2) / 2;
        ctx.fillStyle = '#333';
        ctx.font = `${12 / state.zoomLevel}px sans-serif`;
        ctx.textAlign = 'center';
        ctx.fillText(formatLength(calculateDistance(w.x1, w.y1, w.x2, w.y2)), mx, my - 10 / state.zoomLevel);
        
        if (sel) {
            ctx.fillStyle = '#2196f3';
            const h = 8 / state.zoomLevel;
            ctx.fillRect(w.x1 - h/2, w.y1 - h/2, h, h);
            ctx.fillRect(w.x2 - h/2, w.y2 - h/2, h, h);
            ctx.fillStyle = '#ff9800';
            ctx.beginPath();
            ctx.arc(mx, my, 6 / state.zoomLevel, 0, Math.PI * 2);
            ctx.fill();
        }
    });

    if (state.selectedTool === 'wall' && state.wallStartVertex && state.tempWallEndPos) {
        ctx.strokeStyle = '#ff9800';
        ctx.lineWidth = 2 / state.zoomLevel;
        ctx.setLineDash([5 / state.zoomLevel, 5 / state.zoomLevel]);
        ctx.beginPath();
        ctx.moveTo(state.wallStartVertex.x, state.wallStartVertex.y);
        ctx.lineTo(state.tempWallEndPos.x, state.tempWallEndPos.y);
        ctx.stroke();
        ctx.setLineDash([]);
        
        const mx = (state.wallStartVertex.x + state.tempWallEndPos.x) / 2;
        const my = (state.wallStartVertex.y + state.tempWallEndPos.y) / 2;
        ctx.fillStyle = '#ff9800';
        ctx.font = `bold ${12 / state.zoomLevel}px sans-serif`;
        ctx.textAlign = 'center';
        ctx.fillText(formatLength(calculateDistance(state.wallStartVertex.x, state.wallStartVertex.y, state.tempWallEndPos.x, state.tempWallEndPos.y)), mx, my - 10 / state.zoomLevel);
    }

    state.doors.forEach(d => {
        const sel = state.selectedItem?.id === d.id;
        
        // è¾ºä¸Šã®ä½ç½®ã‚’è¨ˆç®—
        const room = state.rooms.find(r => r.id === d.roomId);
        if (!room) return;
        
        const v1 = room.vertices[d.edgeIndex];
        const v2 = room.vertices[(d.edgeIndex + 1) % room.vertices.length];
        const dx = v2.x - v1.x;
        const dy = v2.y - v1.y;
        
        const x = v1.x + d.t * dx;
        const y = v1.y + d.t * dy;
        const angle = Math.atan2(dy, dx);
        
        ctx.save();
        ctx.translate(x, y);
        ctx.rotate(angle);
        const lw = 4 / state.zoomLevel;
        if (d.doorType === 'swing') {
            ctx.strokeStyle = sel ? '#2196f3' : '#8b4513';
            ctx.lineWidth = lw;
            ctx.beginPath();
            ctx.moveTo(0, 0);
            ctx.lineTo(d.width, 0);
            ctx.stroke();
            ctx.strokeStyle = '#ccc';
            ctx.lineWidth = 1 / state.zoomLevel;
            ctx.beginPath();
            ctx.arc(0, 0, d.width, 0, Math.PI/2);
            ctx.stroke();
        } else {
            ctx.strokeStyle = sel ? '#2196f3' : '#8b4513';
            ctx.lineWidth = lw;
            ctx.beginPath();
            ctx.moveTo(0, -5);
            ctx.lineTo(d.width/2, -5);
            ctx.moveTo(d.width/2, 5);
            ctx.lineTo(d.width, 5);
            ctx.stroke();
        }
        ctx.restore();
    });

    state.windows.forEach(w => {
        const sel = state.selectedItem?.id === w.id;
        
        // è¾ºä¸Šã®ä½ç½®ã‚’è¨ˆç®—
        const room = state.rooms.find(r => r.id === w.roomId);
        if (!room) return;
        
        const v1 = room.vertices[w.edgeIndex];
        const v2 = room.vertices[(w.edgeIndex + 1) % room.vertices.length];
        const dx = v2.x - v1.x;
        const dy = v2.y - v1.y;
        
        const x = v1.x + w.t * dx;
        const y = v1.y + w.t * dy;
        const angle = Math.atan2(dy, dx);
        
        ctx.save();
        ctx.translate(x, y);
        ctx.rotate(angle);
        ctx.strokeStyle = sel ? '#2196f3' : '#4fc3f7';
        ctx.lineWidth = 5 / state.zoomLevel;
        ctx.beginPath();
        ctx.moveTo(0, 0);
        ctx.lineTo(w.width, 0);
        ctx.stroke();
        ctx.strokeStyle = '#b3e5fc';
        ctx.lineWidth = 2 / state.zoomLevel;
        ctx.beginPath();
        ctx.moveTo(w.width/2, -4);
        ctx.lineTo(w.width/2, 4);
        ctx.stroke();
        ctx.restore();
    });

    state.manikins.forEach(m => {
        const sel = state.selectedItem?.id === m.id;
        ctx.save();
        ctx.translate(m.x, m.y);
        ctx.rotate((m.rotation * Math.PI) / 180);
        const s = 20 / state.zoomLevel;
        ctx.strokeStyle = sel ? '#2196f3' : '#ff5722';
        ctx.fillStyle = '#ffccbc';
        ctx.lineWidth = 2 / state.zoomLevel;
        ctx.beginPath();
        ctx.arc(0, -s, s/3, 0, Math.PI * 2);
        ctx.fill();
        ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(0, -s * 0.7);
        ctx.lineTo(0, s * 0.5);
        ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(-s/2, -s * 0.3);
        ctx.lineTo(0, -s * 0.5);
        ctx.lineTo(s/2, -s * 0.3);
        ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(0, s * 0.5);
        ctx.lineTo(-s/3, s * 1.2);
        ctx.moveTo(0, s * 0.5);
        ctx.lineTo(s/3, s * 1.2);
        ctx.stroke();
        ctx.restore();
    });

    ctx.restore();
    updateUI();
}

function updateUI() {
    const ta = getTotalArea();
    document.getElementById('totalArea').textContent = ta;
    document.getElementById('totalAreaTop').textContent = ta;
    document.getElementById('roomCount').textContent = state.rooms.length;
    document.getElementById('scaleDisplay').textContent = Math.round(state.zoomLevel * 100);

    if (state.selectedItem) {
        document.getElementById('selectedPanel').style.display = 'block';
        const tt = { room: 'éƒ¨å±‹', wall: 'å£', door: 'ãƒ‰ã‚¢', window: 'çª“', manikin: 'äººå‹' };
        document.getElementById('selectedType').innerHTML = '<strong>' + tt[state.selectedItem.type] + '</strong>';

        let c = '';
        if (state.selectedItem.type === 'room') {
            c = `<label>éƒ¨å±‹å</label><input type="text" id="roomName" value="${state.selectedItem.name || ''}" placeholder="ä¾‹: ãƒªãƒ“ãƒ³ã‚°">
<label>ç”¨é€”</label><input type="text" id="roomPurpose" value="${state.selectedItem.purpose || ''}" placeholder="ä¾‹: å±…é–“">
<label>è‰²</label><input type="color" id="roomColor" class="color-picker" value="${state.selectedItem.color || '#e3f2fd'}">`;
        } else if (state.selectedItem.type === 'door') {
            c = `<label>ãƒ‰ã‚¢å¹… (cm)</label><input type="number" id="itemWidth" value="${Math.round(state.selectedItem.width / state.scale * 100)}" min="60" max="120" step="5">`;
        } else if (state.selectedItem.type === 'window') {
            c = `<label>çª“å¹… (cm)</label><input type="number" id="itemWidth" value="${Math.round(state.selectedItem.width / state.scale * 100)}" min="60" max="200" step="10">`;
        } else if (state.selectedItem.type === 'wall') {
            const len = Math.sqrt((state.selectedItem.x2 - state.selectedItem.x1) ** 2 + (state.selectedItem.y2 - state.selectedItem.y1) ** 2);
            c = `<label>å£ã®é•·ã• (cm)</label><input type="number" id="wallLength" value="${Math.round(len / state.scale * 100)}" min="10" max="1000" step="5">
<label>å£ã®åšã• (cm)</label><input type="number" id="wallThicknessItem" value="${state.selectedItem.thickness}" min="5" max="50" step="5">`;
        }
        document.getElementById('selectedControls').innerHTML = c;

        setTimeout(() => {
            const rn = document.getElementById('roomName');
            if (rn) rn.addEventListener('input', e => { state.selectedItem.name = e.target.value; draw(); });
            const rp = document.getElementById('roomPurpose');
            if (rp) rp.addEventListener('input', e => { state.selectedItem.purpose = e.target.value; draw(); });
            const rc = document.getElementById('roomColor');
            if (rc) rc.addEventListener('input', e => { state.selectedItem.color = e.target.value; draw(); });
            const iw = document.getElementById('itemWidth');
            if (iw) iw.addEventListener('input', e => { state.selectedItem.width = e.target.value * state.scale / 100; draw(); });
            const wl = document.getElementById('wallLength');
            if (wl) wl.addEventListener('input', e => {
                const nl = e.target.value * state.scale / 100;
                const cl = Math.sqrt((state.selectedItem.x2 - state.selectedItem.x1) ** 2 + (state.selectedItem.y2 - state.selectedItem.y1) ** 2);
                if (cl > 0) {
                    const r = nl / cl;
                    const dx = state.selectedItem.x2 - state.selectedItem.x1, dy = state.selectedItem.y2 - state.selectedItem.y1;
                    state.selectedItem.x2 = state.selectedItem.x1 + dx * r;
                    state.selectedItem.y2 = state.selectedItem.y1 + dy * r;
                    draw();
                }
            });
            const wt = document.getElementById('wallThicknessItem');
            if (wt) wt.addEventListener('input', e => { state.selectedItem.thickness = parseInt(e.target.value); draw(); });
        }, 0);
    } else {
        document.getElementById('selectedPanel').style.display = 'none';
    }
}

function findItemAt(x, y) {
    if (state.selectedTool === 'edit-vertex') {
        for (let r of state.rooms) {
            for (let i = 0; i < r.vertices.length; i++) {
                const v = r.vertices[i];
                if (Math.abs(x - v.x) < 10 / state.zoomLevel && Math.abs(y - v.y) < 10 / state.zoomLevel)
                    return { type: 'vertex', roomId: r.id, index: i, room: r };
            }
        }
    }

    if (state.selectedTool === 'add-vertex') {
        for (let r of state.rooms) {
            for (let i = 0; i < r.vertices.length; i++) {
                const j = (i + 1) % r.vertices.length;
                if (distanceToSegment(x, y, r.vertices[i].x, r.vertices[i].y, r.vertices[j].x, r.vertices[j].y) < 20 / state.zoomLevel)
                    return { type: 'edge-add', roomId: r.id, edgeIndex: i, room: r };
            }
        }
    }

    if (state.selectedTool === 'edit-edge') {
        for (let r of state.rooms) {
            for (let i = 0; i < r.vertices.length; i++) {
                const j = (i + 1) % r.vertices.length;
                const m = getEdgeMidpoint(r.vertices[i], r.vertices[j]);
                if (Math.abs(x - m.x) < 15 / state.zoomLevel && Math.abs(y - m.y) < 15 / state.zoomLevel)
                    return { type: 'edge-move', roomId: r.id, edgeIndex: i, room: r };
                if (distanceToSegment(x, y, r.vertices[i].x, r.vertices[i].y, r.vertices[j].x, r.vertices[j].y) < 20 / state.zoomLevel)
                    return { type: 'edge-move', roomId: r.id, edgeIndex: i, room: r };
            }
        }
    }

if (state.selectedTool === 'select') {
    // é¸æŠä¸­ã®éƒ¨å±‹ã®é ‚ç‚¹ã®ã¿ãƒªã‚µã‚¤ã‚ºå¯èƒ½ã«ã™ã‚‹
    if (state.selectedItem && state.selectedItem.type === 'room') {
        const r = state.rooms.find(rm => rm.id === state.selectedItem.id);
        if (r) {
            for (let i = 0; i < r.vertices.length; i++) {
                const v = r.vertices[i];
                if (Math.abs(x - v.x) < 10 / state.zoomLevel && Math.abs(y - v.y) < 10 / state.zoomLevel)
                    return { type: 'vertex-resize', roomId: r.id, index: i, room: r };
            }
        }
    }
    
    for (let w of state.walls) {
        if (Math.abs(x - w.x1) < 10 / state.zoomLevel && Math.abs(y - w.y1) < 10 / state.zoomLevel)
            return { type: 'wall-endpoint', wall: w, endpoint: 1 };
        if (Math.abs(x - w.x2) < 10 / state.zoomLevel && Math.abs(y - w.y2) < 10 / state.zoomLevel)
            return { type: 'wall-endpoint', wall: w, endpoint: 2 };
        const mx = (w.x1 + w.x2) / 2, my = (w.y1 + w.y2) / 2;
        if (Math.abs(x - mx) < 10 / state.zoomLevel && Math.abs(y - my) < 10 / state.zoomLevel)
            return { type: 'wall-rotate', wall: w };
    }
}

    for (let w of [...state.walls].reverse()) {
        if (distanceToSegment(x, y, w.x1, w.y1, w.x2, w.y2) < (w.thickness / 2 + 5) / state.zoomLevel)
            return { type: 'wall', ...w };
    }
    for (let r of [...state.rooms].reverse()) {
        if (isPointInPolygon({x, y}, r.vertices)) return { type: 'room', ...r };
    }
    for (let d of [...state.doors].reverse()) {
        const room = state.rooms.find(r => r.id === d.roomId);
        if (room) {
            const v1 = room.vertices[d.edgeIndex];
            const v2 = room.vertices[(d.edgeIndex + 1) % room.vertices.length];
            const dx = v2.x - v1.x;
            const dy = v2.y - v1.y;
            const px = v1.x + d.t * dx;
            const py = v1.y + d.t * dy;
            
            if (Math.abs(x - px) < 50 / state.zoomLevel && Math.abs(y - py) < 50 / state.zoomLevel)
                return { type: 'door', ...d };
        }
    }
    for (let w of [...state.windows].reverse()) {
        const room = state.rooms.find(r => r.id === w.roomId);
        if (room) {
            const v1 = room.vertices[w.edgeIndex];
            const v2 = room.vertices[(w.edgeIndex + 1) % room.vertices.length];
            const dx = v2.x - v1.x;
            const dy = v2.y - v1.y;
            const px = v1.x + w.t * dx;
            const py = v1.y + w.t * dy;
            
            if (Math.abs(x - px) < 50 / state.zoomLevel && Math.abs(y - py) < 50 / state.zoomLevel)
                return { type: 'window', ...w };
        }
    }
    for (let m of [...state.manikins].reverse()) {
        if (Math.abs(x - m.x) < 30 / state.zoomLevel && Math.abs(y - m.y) < 30 / state.zoomLevel)
            return { type: 'manikin', ...m };
    }
    return null;
}

canvas.addEventListener('mousedown', e => {
    const rect = canvas.getBoundingClientRect();
    const x = ((e.clientX - rect.left) - state.panOffset.x) / state.zoomLevel;
    const y = ((e.clientY - rect.top) - state.panOffset.y) / state.zoomLevel;
    
    // å³ã‚¯ãƒªãƒƒã‚¯ã¾ãŸã¯Ctrl+ã‚¯ãƒªãƒƒã‚¯ã§ãƒ‘ãƒ³é–‹å§‹
    if (e.button === 2 || e.ctrlKey) {
        e.preventDefault();
        state.isPanning = true;
        state.dragStart = { x: e.clientX, y: e.clientY };
        canvas.style.cursor = 'grabbing';
        return;
    }
    
    const f = findItemAt(x, y);

    if (state.selectedTool === 'wall') {
        const v = findNearestVertex(x, y, 15);
        if (v) {
            if (!state.wallStartVertex) {
                state.wallStartVertex = v;
                draw();
            } else {
                state.walls.push({
                    id: Date.now(), type: 'wall',
                    x1: state.wallStartVertex.x, y1: state.wallStartVertex.y,
                    x2: v.x, y2: v.y, thickness: state.wallThickness
                });
                state.wallStartVertex = null;
                state.tempWallEndPos = null;
                saveHistory();
                draw();
            }
            return;
        }
    }

    if (f && f.type === 'wall') {
        state.selectedItem = f;
        state.selectedTool = 'select';
        document.querySelectorAll('.tool-btn[data-tool]').forEach(b => b.classList.remove('active'));
        document.querySelector('.tool-btn[data-tool="select"]').classList.add('active');
        draw();
        return;
    }

    if (state.selectedTool === 'add-vertex' && f && f.type === 'edge-add') {
        const r = state.rooms.find(rm => rm.id === f.roomId);
        if (r) {
            r.vertices.splice(f.edgeIndex + 1, 0, snapPointToGrid({ x, y }));
            state.selectedItem = r;
            saveHistory();
            switchToSelectTool();
            draw();
        }
        return;
    }

    if (state.selectedTool === 'edit-edge' && f && f.type === 'edge-move') {
        state.selectedEdge = { roomId: f.roomId, index: f.edgeIndex };
        state.selectedItem = f.room;
        state.isDragging = true;
        state.dragStart = { x: snapToGrid(x), y: snapToGrid(y) };
        
        const r = state.rooms.find(rm => rm.id === f.roomId);
        const i = f.edgeIndex, j = (i + 1) % r.vertices.length;
        const ev = { x: r.vertices[j].x - r.vertices[i].x, y: r.vertices[j].y - r.vertices[i].y };
        const el = Math.sqrt(ev.x ** 2 + ev.y ** 2);
        state.edgeNormal = { x: -ev.y / el, y: ev.x / el };
        draw();
        return;
    }

    if (state.selectedTool === 'edit-vertex' && f && f.type === 'vertex') {
        state.selectedVertex = { roomId: f.roomId, index: f.index };
        state.selectedItem = f.room;
        state.isDragging = true;
        state.dragStart = { x, y };
        draw();
        return;
    }

    if (state.selectedTool === 'select') {
        if (f && f.type === 'wall-endpoint') {
            state.selectedItem = f.wall;
            state.selectedVertex = { endpoint: f.endpoint };
            state.isDragging = true;
            state.dragStart = { x, y };
        } else if (f && f.type === 'wall-rotate') {
            state.selectedItem = f.wall;
            state.isDragging = true;
            state.isRotating = true;
            state.dragStart = { x, y };
        } else if (f && f.type === 'vertex-resize') {
            state.selectedVertex = { roomId: f.roomId, index: f.index };
            state.selectedItem = f.room;
            state.isDragging = true;
            state.dragStart = { x, y };
        } else if (f) {
            state.selectedItem = f;
            state.selectedVertex = null;
            state.selectedEdge = null;
            state.isDragging = true;
            state.dragStart = { x, y };
            state.dragOffset = { x: x - (f.x || 0), y: y - (f.y || 0) };
        } else {
            state.selectedItem = null;
            state.selectedVertex = null;
            state.selectedEdge = null;
        }
        draw();
        return;
    }

    if (!f) {
        const sx = snapToGrid(x), sy = snapToGrid(y);
        if (state.selectedTool === 'room') {
            const newRoom = {
                id: Date.now(), type: 'room',
                vertices: [{ x: sx, y: sy }, { x: sx + 63, y: sy }, { x: sx + 63, y: sy + 63 }, { x: sx, y: sy + 63 }],
                name: 'éƒ¨å±‹' + (state.rooms.length + 1), purpose: '', color: '#e3f2fd'
            };
            state.rooms.push(newRoom);
            state.selectedItem = newRoom;
            saveHistory();
            switchToSelectTool();            
        } else if (state.selectedTool === 'door-swing' || state.selectedTool === 'door-sliding') {
            const edge = findNearestEdge(x, y, 30);
            if (edge) {
                state.doors.push({ 
                    id: Date.now(), 
                    type: 'door', 
                    doorType: state.selectedTool === 'door-swing' ? 'swing' : 'sliding',
                    roomId: edge.roomId,
                    edgeIndex: edge.edgeIndex,
                    t: edge.t,
                    width: 80,  // 80cm
                    rotation: edge.angle
                });
                saveHistory();
            }
        } else if (state.selectedTool === 'window') {
            const edge = findNearestEdge(x, y, 30);
            if (edge) {
                state.windows.push({ 
                    id: Date.now(), 
                    type: 'window',
                    roomId: edge.roomId,
                    edgeIndex: edge.edgeIndex,
                    t: edge.t,
                    width: 90,  // 90cm
                    rotation: edge.angle
                });
                saveHistory();
            }
        } else if (state.selectedTool === 'manikin') {
            state.manikins.push({ id: Date.now(), type: 'manikin', x: sx, y: sy, rotation: 0 });
            saveHistory();
        }
        draw();
    } else if (state.selectedTool === 'select') {
        // ç©ºç™½éƒ¨åˆ†ã‚’ã‚¯ãƒªãƒƒã‚¯ã—ãŸå ´åˆã¯ãƒ‘ãƒ³é–‹å§‹
        state.isPanning = true;
        state.dragStart = { x: e.clientX, y: e.clientY };
    }
});

canvas.addEventListener('mousemove', e => {
    const rect = canvas.getBoundingClientRect();
    const x = ((e.clientX - rect.left) - state.panOffset.x) / state.zoomLevel;
    const y = ((e.clientY - rect.top) - state.panOffset.y) / state.zoomLevel;

    if (state.isPanning) {
        // ãƒ‘ãƒ³å‡¦ç†
        const dx = e.clientX - state.dragStart.x;
        const dy = e.clientY - state.dragStart.y;
        state.panOffset.x += dx;
        state.panOffset.y += dy;
        state.dragStart = { x: e.clientX, y: e.clientY };
        draw();
        return;
    }

    if (state.selectedTool === 'wall' && state.wallStartVertex) {
        const nv = findNearestVertex(x, y, 15);
        state.tempWallEndPos = nv || snapPointToGrid({ x, y });
        draw();
        return;
    }

    if (state.isDragging) {
        if (state.isRotating && state.selectedItem && state.selectedItem.type === 'wall') {
            const w = state.selectedItem;
            const cx = (w.x1 + w.x2) / 2, cy = (w.y1 + w.y2) / 2;
            const len = Math.sqrt((w.x2 - w.x1) ** 2 + (w.y2 - w.y1) ** 2);
            const ang = Math.atan2(y - cy, x - cx);
            w.x1 = cx - Math.cos(ang) * len / 2;
            w.y1 = cy - Math.sin(ang) * len / 2;
            w.x2 = cx + Math.cos(ang) * len / 2;
            w.y2 = cy + Math.sin(ang) * len / 2;
            draw();
        } else if (state.selectedVertex && state.selectedVertex.endpoint) {
            const w = state.selectedItem;
            const nv = findNearestVertex(x, y, 15);
            const tp = nv || snapPointToGrid({ x, y });
            if (state.selectedVertex.endpoint === 1) {
                w.x1 = tp.x; w.y1 = tp.y;
            } else {
                w.x2 = tp.x; w.y2 = tp.y;
            }
            draw();
            } else if (state.selectedVertex && state.selectedVertex.roomId && state.selectedTool === 'select') {
                const r = state.rooms.find(rm => rm.id === state.selectedVertex.roomId);
                if (r && e.shiftKey && r.vertices.length === 4) {
                    // ShiftæŠ¼ä¸‹æ™‚: å¯¾è§’ã®ç‚¹ã‚’å›ºå®šã—ã¦æ­£æ–¹å½¢ã‚’ä¿ã¡ãªãŒã‚‰ãƒªã‚µã‚¤ã‚º
                    const idx = state.selectedVertex.index;
                    const oppositeIdx = (idx + 2) % 4; // å¯¾è§’ã®ç‚¹
                    const fixedPoint = r.vertices[oppositeIdx];
                    
                    // æ–°ã—ã„ä½ç½®ã‚’ã‚¹ãƒŠãƒƒãƒ—
                    const newPos = snapPointToGrid({ x, y });
                    
                    // å›ºå®šç‚¹ã‹ã‚‰æ–°ã—ã„ä½ç½®ã¾ã§ã®è·é›¢
                    const dx = newPos.x - fixedPoint.x;
                    const dy = newPos.y - fixedPoint.y;
                    const size = Math.max(Math.abs(dx), Math.abs(dy));
                    
                    // ç¬¦å·ã‚’ä¿æŒ
                    const signX = dx >= 0 ? 1 : -1;
                    const signY = dy >= 0 ? 1 : -1;
                    
                    // 4ç‚¹ã‚’æ­£æ–¹å½¢ã«é…ç½®ï¼ˆå¯¾è§’ç‚¹ã¯å›ºå®šï¼‰
                    r.vertices[oppositeIdx] = fixedPoint; // å¯¾è§’ç‚¹ã¯å›ºå®š
                    r.vertices[idx] = { x: fixedPoint.x + signX * size, y: fixedPoint.y + signY * size }; // ãƒ‰ãƒ©ãƒƒã‚°ä¸­ã®ç‚¹
                    r.vertices[(idx + 1) % 4] = { x: fixedPoint.x + signX * size, y: fixedPoint.y }; // éš£æ¥ç‚¹1
                    r.vertices[(idx + 3) % 4] = { x: fixedPoint.x, y: fixedPoint.y + signY * size }; // éš£æ¥ç‚¹2
                    
                    state.selectedItem = r;
                    } else if (r && r.vertices.length === 4) {
                            // Shiftãªã—: å¯¾è§’ã®ç‚¹ã‚’å›ºå®šã—ã¦å››è§’å½¢ã‚’ä¿ã¡ãªãŒã‚‰é•·æ–¹å½¢ã«å¤‰å½¢
                            const idx = state.selectedVertex.index;
                            const oppositeIdx = (idx + 2) % 4; // å¯¾è§’ã®ç‚¹
                            const fixedPoint = r.vertices[oppositeIdx];
                            
                            // æ–°ã—ã„ä½ç½®ã‚’ã‚¹ãƒŠãƒƒãƒ—
                            const newPos = snapPointToGrid({ x, y });
                            
                            // å›ºå®šç‚¹ã‹ã‚‰æ–°ã—ã„ä½ç½®ã¾ã§ã®è·é›¢ï¼ˆX, Yã¯ç‹¬ç«‹ï¼‰
                            const dx = newPos.x - fixedPoint.x;
                            const dy = newPos.y - fixedPoint.y;
                            
                            // æ–°ã—ã„4ç‚¹ã®åº§æ¨™ã‚’è¨ˆç®—ï¼ˆé•·æ–¹å½¢ï¼‰
                            const newVertices = [
                                { x: fixedPoint.x, y: fixedPoint.y },
                                { x: fixedPoint.x + dx, y: fixedPoint.y },
                                { x: fixedPoint.x + dx, y: fixedPoint.y + dy },
                                { x: fixedPoint.x, y: fixedPoint.y + dy }
                            ];
                            
                            // oppositeIdxãŒ0ã«ãªã‚‹ã‚ˆã†ã«å›è»¢
                            const rotatedVertices = [];
                            for (let i = 0; i < 4; i++) {
                                rotatedVertices[i] = newVertices[(i + oppositeIdx) % 4];
                            }
                            
                            r.vertices = rotatedVertices;
                            state.selectedItem = r;
                        } else if (r) {
                            // 4è§’å½¢ä»¥å¤–ã®å ´åˆã¯ç‚¹ã ã‘å‹•ã‹ã™
                            r.vertices[state.selectedVertex.index] = snapPointToGrid({ x, y });
                            state.selectedItem = r;
                        }
                draw();
            } else if (state.selectedVertex && state.selectedVertex.roomId) {
                // edit-vertexãƒ¢ãƒ¼ãƒ‰æ™‚ã¯å¾“æ¥é€šã‚Š
                const r = state.rooms.find(rm => rm.id === state.selectedVertex.roomId);
                if (r) {
                    r.vertices[state.selectedVertex.index] = snapPointToGrid({ x, y });
                    state.selectedItem = r;
                }
                draw();
            }
            else if (state.selectedEdge) {
            const r = state.rooms.find(rm => rm.id === state.selectedEdge.roomId);
            if (r && state.edgeNormal) {
                const dx = x - state.dragStart.x, dy = y - state.dragStart.y;
                const nd = dx * state.edgeNormal.x + dy * state.edgeNormal.y;
                const mx = nd * state.edgeNormal.x, my = nd * state.edgeNormal.y;
                const smx = snapToGrid(mx), smy = snapToGrid(my);
                
                if (smx !== 0 || smy !== 0) {
                    const i = state.selectedEdge.index, j = (i + 1) % r.vertices.length;
                    r.vertices[i] = { x: r.vertices[i].x + smx, y: r.vertices[i].y + smy };
                    r.vertices[j] = { x: r.vertices[j].x + smx, y: r.vertices[j].y + smy };
                    state.dragStart = { x: state.dragStart.x + smx, y: state.dragStart.y + smy };
                    state.selectedItem = r;
                    draw();
                }
            }
        } else if (state.selectedItem && state.selectedItem.type === 'room' && state.selectedTool === 'select') {
            const dx = x - state.dragStart.x, dy = y - state.dragStart.y;
            const r = state.rooms.find(rm => rm.id === state.selectedItem.id);
            if (r) {
                r.vertices = r.vertices.map(v => snapPointToGrid({ x: v.x + dx, y: v.y + dy }));
                state.selectedItem = r;
            }
            state.dragStart = { x, y };
            draw();
        } else if (state.selectedItem && state.selectedItem.type === 'wall' && state.selectedTool === 'select') {
            const dx = x - state.dragStart.x, dy = y - state.dragStart.y;
            state.selectedItem.x1 += dx; state.selectedItem.y1 += dy;
            state.selectedItem.x2 += dx; state.selectedItem.y2 += dy;
            state.dragStart = { x, y };
            draw();
        } else if (state.selectedItem && (state.selectedItem.type === 'door' || state.selectedItem.type === 'window')) {
            // ãƒ‰ã‚¢ãƒ»çª“ã¯è¾ºã«æ²¿ã£ã¦ç§»å‹•
            const edge = findNearestEdge(x, y, 100);
            if (edge && edge.roomId === state.selectedItem.roomId && edge.edgeIndex === state.selectedItem.edgeIndex) {
                state.selectedItem.t = Math.max(0, Math.min(1, edge.t));
                draw();
            }
        } else if (state.selectedItem) {
            const nx = snapToGrid(x - state.dragOffset.x), ny = snapToGrid(y - state.dragOffset.y);
            state.selectedItem.x = nx; state.selectedItem.y = ny;
            draw();
        }
    }
});

canvas.addEventListener('mouseup', () => {
    if (state.isDragging) {
        saveHistory();
    }
    state.isDragging = false;
    state.isRotating = false;
    state.isPanning = false;
    state.selectedEdge = null;
    state.edgeNormal = null;
});

// å³ã‚¯ãƒªãƒƒã‚¯ãƒ¡ãƒ‹ãƒ¥ãƒ¼ã‚’ç„¡åŠ¹åŒ–
canvas.addEventListener('contextmenu', e => {
    e.preventDefault();
});

document.querySelectorAll('.tool-btn[data-tool]').forEach(b => {
    b.addEventListener('click', () => {
        document.querySelectorAll('.tool-btn[data-tool]').forEach(btn => btn.classList.remove('active'));
        b.classList.add('active');
        state.selectedTool = b.dataset.tool;
        state.selectedVertex = null;
        state.selectedEdge = null;
        state.wallStartVertex = null;
        state.tempWallEndPos = null;
        canvas.style.cursor = state.selectedTool === 'add-vertex' ? 'crosshair' : 'default';
        draw();
    });
});

document.getElementById('wallThickness').addEventListener('input', e => { state.wallThickness = parseInt(e.target.value); });
document.getElementById('gridSize').addEventListener('input', e => { state.gridSize = parseInt(e.target.value); draw(); });
document.getElementById('toggleGrid').addEventListener('click', () => {
    state.showGrid = !state.showGrid;
    document.getElementById('toggleGrid').textContent = 'ğŸ“ ã‚°ãƒªãƒƒãƒ‰: ' + (state.showGrid ? 'ON' : 'OFF');
    draw();
});
document.getElementById('zoomIn').addEventListener('click', () => { state.zoomLevel = Math.min(state.zoomLevel + 0.1, 3.0); draw(); });
document.getElementById('zoomOut').addEventListener('click', () => { state.zoomLevel = Math.max(state.zoomLevel - 0.1, 0.3); draw(); });
document.getElementById('zoomReset').addEventListener('click', () => { state.zoomLevel = 1.0; draw(); });

document.getElementById('resetPan').addEventListener('click', () => { 
    state.panOffset = { x: 0, y: 0 };
    state.zoomLevel = 1.5;
    draw(); 
});

document.getElementById('rotateBtn').addEventListener('click', () => {
    if (!state.selectedItem) return;
    if (state.selectedItem.type === 'room') {
        const c = getPolygonCenter(state.selectedItem.vertices);
        state.selectedItem.vertices = state.selectedItem.vertices.map(v => {
            const dx = v.x - c.x, dy = v.y - c.y;
            return { x: c.x - dy, y: c.y + dx };
        });
    } else if (state.selectedItem.rotation !== undefined) {
        state.selectedItem.rotation = (state.selectedItem.rotation + 90) % 360;
    }
    saveHistory();
    draw();
});

document.getElementById('deleteBtn').addEventListener('click', () => {
    if (!state.selectedItem) return;
    if (state.selectedItem.type === 'room') state.rooms = state.rooms.filter(r => r.id !== state.selectedItem.id);
    else if (state.selectedItem.type === 'wall') state.walls = state.walls.filter(w => w.id !== state.selectedItem.id);
    else if (state.selectedItem.type === 'door') state.doors = state.doors.filter(d => d.id !== state.selectedItem.id);
    else if (state.selectedItem.type === 'window') state.windows = state.windows.filter(w => w.id !== state.selectedItem.id);
    else if (state.selectedItem.type === 'manikin') state.manikins = state.manikins.filter(m => m.id !== state.selectedItem.id);
    state.selectedItem = null;
    state.selectedVertex = null;
    state.selectedEdge = null;
    saveHistory();
    draw();
});

document.getElementById('saveBtn').addEventListener('click', () => {
    const data = { rooms: state.rooms, walls: state.walls, doors: state.doors, windows: state.windows, manikins: state.manikins };
    const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
    const a = document.createElement('a');
    a.href = URL.createObjectURL(blob);
    a.download = 'é–“å–ã‚Š_' + new Date().toISOString().slice(0, 10) + '.json';
    a.click();
});

document.getElementById('loadBtn').addEventListener('click', () => { document.getElementById('fileInput').click(); });
document.getElementById('fileInput').addEventListener('change', e => {
    const f = e.target.files[0];
    if (!f) return;
    const r = new FileReader();
    r.onload = ev => {
        try {
            const d = JSON.parse(ev.target.result);
            state.rooms = d.rooms || [];
            state.walls = d.walls || [];
            state.doors = d.doors || [];
            state.windows = d.windows || [];
            state.manikins = d.manikins || [];
            state.selectedItem = null;
            state.selectedVertex = null;
            state.selectedEdge = null;
            draw();
            alert('èª­ã¿è¾¼ã¿å®Œäº†ï¼');
        } catch { alert('èª­ã¿è¾¼ã¿å¤±æ•—'); }
    };
    r.readAsText(f);
});

document.getElementById('exportBtn').addEventListener('click', () => {
    const a = document.createElement('a');
    a.download = 'é–“å–ã‚Š_' + new Date().toISOString().slice(0, 10) + '.png';
    a.href = canvas.toDataURL();
    a.click();
});

document.getElementById('setLandBtn').addEventListener('click', () => {
    const width = parseFloat(document.getElementById('landWidth').value);
    const depth = parseFloat(document.getElementById('landDepth').value);
    
    if (width && depth) {
        const marginX = 50;
        const marginY = 50;
        state.landBoundary = {
            x: marginX,
            y: marginY,
            width: width * state.scale,
            height: depth * state.scale
        };
        saveHistory();
        draw();
    }
});

document.getElementById('clearLandBtn').addEventListener('click', () => {
    state.landBoundary = null;
    saveHistory();
    draw();
});

document.getElementById('clearBtn').addEventListener('click', () => {
    if (confirm('ã™ã¹ã¦å‰Šé™¤ã—ã¾ã™ã‹?')) {
        state.rooms = []; state.walls = []; state.doors = []; state.windows = []; state.manikins = [];
        state.selectedItem = null; state.selectedVertex = null; state.selectedEdge = null;
        saveHistory();
        draw();
    }
});

// ã‚¿ãƒƒãƒã‚¤ãƒ™ãƒ³ãƒˆå¯¾å¿œ
let lastTouchEnd = 0;

canvas.addEventListener('touchstart', e => {
    if (e.touches.length === 1) {
        e.preventDefault();
        const touch = e.touches[0];
        
        const rect = canvas.getBoundingClientRect();
        const x = ((touch.clientX - rect.left) - state.panOffset.x) / state.zoomLevel;
        const y = ((touch.clientY - rect.top) - state.panOffset.y) / state.zoomLevel;
        
        // ã‚¢ã‚¤ãƒ†ãƒ ãŒãªã„å ´æ‰€ãªã‚‰ãƒ‘ãƒ³é–‹å§‹
        const f = findItemAt(x, y);
        if (!f && state.selectedTool === 'select') {
            state.isPanning = true;
            state.dragStart = { x: touch.clientX, y: touch.clientY };
        } else {
            const mouseEvent = new MouseEvent('mousedown', {
                clientX: touch.clientX,
                clientY: touch.clientY,
                bubbles: true
            });
            canvas.dispatchEvent(mouseEvent);
        }
    }
}, { passive: false });

canvas.addEventListener('touchmove', e => {
    e.preventDefault();
    if (e.touches.length === 1) {
        const touch = e.touches[0];
        
        // ãƒ‘ãƒ³ä¸­ã®å ´åˆã¯ç›´æ¥ãƒ‘ãƒ³å‡¦ç†ã‚’å®Ÿè¡Œ
        if (state.isPanning) {
            const dx = touch.clientX - state.dragStart.x;
            const dy = touch.clientY - state.dragStart.y;
            state.panOffset.x += dx;
            state.panOffset.y += dy;
            state.dragStart = { x: touch.clientX, y: touch.clientY };
            draw();
        } else {
            const mouseEvent = new MouseEvent('mousemove', {
                clientX: touch.clientX,
                clientY: touch.clientY,
                bubbles: true
            });
            canvas.dispatchEvent(mouseEvent);
        }
    }
}, { passive: false });

canvas.addEventListener('touchend', e => {
    e.preventDefault();
    const now = Date.now();
    if (now - lastTouchEnd <= 300) {
        // ãƒ€ãƒ–ãƒ«ã‚¿ãƒƒãƒ—ã§ã‚ºãƒ¼ãƒ ãƒªã‚»ãƒƒãƒˆ
        state.zoomLevel = 1.0;
        draw();
    }
    lastTouchEnd = now;
    
    const mouseEvent = new MouseEvent('mouseup', {
        bubbles: true
    });
    canvas.dispatchEvent(mouseEvent);
}, { passive: false });

// ãƒ”ãƒ³ãƒã‚ºãƒ¼ãƒ å¯¾å¿œ
let lastDistance = 0;
canvas.addEventListener('touchstart', e => {
    if (e.touches.length === 2) {
        const dx = e.touches[0].clientX - e.touches[1].clientX;
        const dy = e.touches[0].clientY - e.touches[1].clientY;
        lastDistance = Math.sqrt(dx * dx + dy * dy);
    }
}, { passive: true });

canvas.addEventListener('touchmove', e => {
    if (e.touches.length === 2) {
        e.preventDefault();
        const dx = e.touches[0].clientX - e.touches[1].clientX;
        const dy = e.touches[0].clientY - e.touches[1].clientY;
        const distance = Math.sqrt(dx * dx + dy * dy);
        
        if (lastDistance > 0) {
            const delta = distance - lastDistance;
            state.zoomLevel = Math.max(0.3, Math.min(3.0, state.zoomLevel + delta * 0.01));
            draw();
        }
        lastDistance = distance;
    }
}, { passive: false });

// å…ƒã«æˆ»ã™ãƒ»ã‚„ã‚Šç›´ã—ãƒœã‚¿ãƒ³
document.getElementById('undoBtn').addEventListener('click', undo);
document.getElementById('redoBtn').addEventListener('click', redo);

document.addEventListener('keydown', e => {
    if (e.key === 'Delete' && state.selectedItem) document.getElementById('deleteBtn').click();
    else if (e.key === 'r' && state.selectedItem) document.getElementById('rotateBtn').click();
    else if ((e.ctrlKey || e.metaKey) && e.key === 'z' && !e.shiftKey) {
        e.preventDefault();
        undo();
    } else if ((e.ctrlKey || e.metaKey) && (e.key === 'y' || (e.key === 'z' && e.shiftKey))) {
        e.preventDefault();
        redo();
    }
});

// åˆæœŸå±¥æ­´ã‚’ä¿å­˜
saveHistory();
draw();
    </script>
</body>
</html>
