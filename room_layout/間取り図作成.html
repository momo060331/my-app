<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>é–“å–ã‚Šå›³ä½œæˆã‚¢ãƒ—ãƒª</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: 'Segoe UI', sans-serif; display: flex; height: 100vh; background: #f5f5f5; }
        #sidebar { width: 280px; background: white; box-shadow: 2px 0 5px rgba(0,0,0,0.1); padding: 20px; overflow-y: auto; }
        h1 { font-size: 20px; margin-bottom: 10px; color: #333; }
        .total-area-display { background: #4caf50; color: white; padding: 12px; border-radius: 4px; margin-bottom: 20px; font-size: 16px; font-weight: bold; text-align: center; }
        .section { margin-bottom: 20px; }
        .section-title { font-size: 14px; font-weight: bold; margin-bottom: 10px; color: #555; }
        button { width: 100%; padding: 10px; margin-bottom: 8px; border: none; border-radius: 4px; cursor: pointer; font-size: 13px; transition: all 0.2s; }
        button:hover { opacity: 0.9; }
        .tool-btn { background: #e0e0e0; color: #333; }
        .tool-btn.active { background: #2196f3; color: white; }
        .action-btn { background: #4caf50; color: white; }
        .danger-btn { background: #f44336; color: white; }
        .info-btn { background: #ff9800; color: white; }
        input, select { width: 100%; padding: 8px; margin-bottom: 10px; border: 1px solid #ddd; border-radius: 4px; font-size: 13px; }
        label { display: block; font-size: 12px; color: #666; margin-bottom: 4px; }
        #canvas-container { flex: 1; padding: 20px; overflow: auto; }
        canvas { background: white; box-shadow: 0 2px 10px rgba(0,0,0,0.1); cursor: crosshair; border-radius: 4px; }
        .selected-info { background: #e3f2fd; padding: 15px; border-radius: 4px; margin-bottom: 15px; }
        .info-box { background: #f5f5f5; padding: 12px; border-radius: 4px; font-size: 13px; }
        .info-box p { margin: 5px 0; }
        .btn-group { display: flex; gap: 8px; }
        .btn-group button { flex: 1; margin-bottom: 8px; }
        .color-picker { height: 40px; cursor: pointer; }
        .hint { background: #fff3cd; padding: 8px; border-radius: 4px; font-size: 11px; color: #856404; margin-top: 8px; }
        .total-area-display button {
            background: #4caf50 !important;
        }
        #furnitureList button {
            font-size: 12px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        /* ãƒ¢ãƒã‚¤ãƒ«å¯¾å¿œ */
        @media (max-width: 768px) {
            body { flex-direction: column; }
            #sidebar {
                width: 100%;
                max-height: 40vh;
                overflow-y: auto;
                padding: 10px;
            }
            h1 { font-size: 16px; margin-bottom: 10px; }
            .total-area-display { 
                font-size: 11px !important; 
                padding: 6px !important; 
                margin-bottom: 10px; 
            }
            .total-area-display button {
                font-size: 11px !important;
                padding: 4px 6px !important;
                min-width: 28px !important;
                background: #4caf50 !important;
            }
            .section { margin-bottom: 10px; }
            .section-title { font-size: 12px; }
            button { padding: 8px; font-size: 12px; margin-bottom: 4px; }
            input { padding: 6px; font-size: 12px; }
            label { font-size: 11px; }
            #canvas-container { padding: 10px; flex: 1; }
            canvas { width: 100%; height: auto; max-width: 100%; }
            .hint { font-size: 10px; padding: 6px; }
        }
        
        /* ã‚¿ãƒƒãƒæ“ä½œç”¨ */
        canvas { touch-action: none; }
        button { -webkit-tap-highlight-color: transparent; }
    </style>
</head>
<body>
    <div id="sidebar">
        <h1>ğŸ  é–“å–ã‚Šå›³ä½œæˆ</h1>
        <div class="total-area-display" style="display: flex; align-items: center; justify-content: center; gap: 6px; flex-wrap: nowrap;">
            <button class="info-btn" id="undoBtn" disabled style="padding: 6px 10px; margin: 0; font-size: 14px; min-width: 36px;">â®ï¸</button>
            <span style="white-space: nowrap;">ç·é¢ç©: <span id="totalAreaTop">0.0</span> ç•³</span>
            <button class="info-btn" id="redoBtn" disabled style="padding: 6px 10px; margin: 0; font-size: 14px; min-width: 36px;">â­ï¸</button>
        </div>
        
        <div class="section">
            <div class="section-title">ãƒ„ãƒ¼ãƒ«é¸æŠ</div>
            <div class="btn-group">
                <button class="tool-btn active" data-tool="select">âœ‹ é¸æŠ</button>
                <button class="tool-btn" data-tool="pan">ğŸ–ï¸ ç§»å‹•</button>
            </div>
            <button class="tool-btn" data-tool="delete">ğŸ—‘ï¸ å‰Šé™¤</button>
            <div class="btn-group">
                <button class="tool-btn" data-tool="room">ğŸ  å››è§’</button>
                <button class="tool-btn" data-tool="polygon">ğŸ“ å¤šè§’å½¢</button>
            </div>
            <div class="btn-group">
                <button class="tool-btn" data-tool="edit-vertex">ğŸ“ ç·¨é›†</button>
                <button class="tool-btn" data-tool="add-vertex">â• è¿½åŠ </button>
                <button class="tool-btn" data-tool="edit-edge">ğŸ“ è¾º</button>
            </div>
            <button class="tool-btn" data-tool="wall">ğŸ§± å£è¿½åŠ </button>
            <div class="btn-group">
                <button class="tool-btn" data-tool="door-swing">ğŸšªé–‹</button>
                <button class="tool-btn" data-tool="door-sliding">ğŸšªå¼•</button>
                <button class="tool-btn" data-tool="window">ğŸªŸçª“</button>
            </div>
            <div class="btn-group">
                <button class="tool-btn" data-tool="manikin">ğŸš¶ äººå‹</button>
                <button class="tool-btn" data-tool="dimension">ğŸ“ å¯¸æ³•</button>
            </div>
            <button class="tool-btn" data-tool="multi-select">ğŸ”² è¤‡æ•°é¸æŠ</button>
                        <!-- è¤‡æ•°é¸æŠæ™‚ã®ã‚¯ã‚¤ãƒƒã‚¯ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ -->
            <div id="multiSelectQuickActions" style="display:none; margin-top: 8px;">
                <div style="font-size: 11px; color: #666; margin-bottom: 4px;">é¸æŠä¸­: <span id="selectedCountQuick">0</span>å€‹</div>
                <div class="btn-group">
                    <button class="action-btn" id="unionBtnQuick" style="font-size: 12px; padding: 6px;">â• åˆæˆ</button>
                    <button class="info-btn" id="subtractBtnQuick" style="font-size: 12px; padding: 6px;">â– æ¸›ç®—</button>
                </div>
                <button class="danger-btn" id="clearSelectionBtnQuick" style="font-size: 12px; padding: 6px; margin-top: 4px;">âŒ é¸æŠè§£é™¤</button>
            </div>
            <div class="hint">ğŸ’¡ å‰Šé™¤: é€£ç¶šã‚¯ãƒªãƒƒã‚¯ã§å‰Šé™¤<br>ğŸ’¡ å£è¿½åŠ : é ‚ç‚¹2ã¤ã‚¯ãƒªãƒƒã‚¯<br>ğŸ’¡ è¤‡æ•°é¸æŠ: éƒ¨å±‹ã‚’é †ç•ªã«ã‚¯ãƒªãƒƒã‚¯<br>ğŸ’¡ ç”»é¢ç§»å‹•: ğŸ–ï¸ç§»å‹•ãƒœã‚¿ãƒ³ or å³ã‚¯ãƒªãƒƒã‚¯<br>ğŸ’¡ å¤šè§’å½¢: å³ã‚¯ãƒªãƒƒã‚¯ or åŒã˜ç‚¹2å›ã§å–æ¶ˆ</div>
            

            </div>

            <div class="section">
                <div class="section-title">æ•·åœ°è¨­å®š</div>
            <label>æ•·åœ°ã®å¹… (m)</label>
            <input type="number" id="landWidth" value="10.1" min="5" max="100" step="0.1">
            <label>æ•·åœ°ã®å¥¥è¡Œã (m)</label>
            <input type="number" id="landDepth" value="10" min="5" max="100" step="0.1">
            <button class="action-btn" id="setLandBtn">æ•·åœ°ç¯„å›²ã‚’è¡¨ç¤º</button>
            <button class="info-btn" id="clearLandBtn" style="margin-top:4px;">æ•·åœ°ç¯„å›²ã‚’æ¶ˆå»</button>
        </div>
        
        <div class="section">
            <div class="section-title">è¡¨ç¤ºè¨­å®š</div>
            <label>æ‹¡å¤§ç¸®å° (<span id="scaleDisplay">100</span>%)</label>
            <div class="btn-group">
                <button class="info-btn" id="zoomOut">ğŸ”âˆ’</button>
                <button class="info-btn" id="zoomReset">100%</button>
                <button class="info-btn" id="zoomIn">ğŸ”+</button>
            </div>
            <button class="tool-btn" id="toggleGrid" style="margin-top:8px;">ğŸ“ ã‚°ãƒªãƒƒãƒ‰: ON</button>
            <button class="info-btn" id="resetPan" style="margin-top:4px;">ğŸ¯ è¡¨ç¤ºãƒªã‚»ãƒƒãƒˆ</button>
        </div>
        
        <div class="section">
            <div class="section-title">å®¶å…·ãƒ»è¨­å‚™</div>
            <select id="furnitureCategory">
                <option value="kitchen">ã‚­ãƒƒãƒãƒ³</option>
                <option value="bath">æµ´å®¤</option>
                <option value="furniture">å®¶å…·</option>
                <option value="appliance">å®¶é›»</option>
            </select>
            <div id="furnitureList" style="max-height: 200px; overflow-y: auto; margin-top: 8px;">
                <!-- å®¶å…·ãƒªã‚¹ãƒˆãŒã“ã“ã«è¡¨ç¤ºã•ã‚Œã‚‹ -->
            </div>
            <button class="action-btn" id="addCustomFurniture" style="margin-top: 8px;">ğŸ“¦ ã‚«ã‚¹ã‚¿ãƒ å®¶å…·ä½œæˆ</button>
        </div>

        <div class="section">
            <div class="section-title">åŸºæœ¬è¨­å®š</div>
            <label>å£ã®åšã• (cm)</label>
            <input type="number" id="wallThickness" value="12" min="5" max="30">
            <label>ã‚°ãƒªãƒƒãƒ‰åˆ»ã¿ (cm)</label>
            <input type="number" id="gridSize" value="45" min="5" max="200" step="5">
        </div>

        <div id="selectedPanel" style="display:none;">
            <div class="section selected-info">
                <div class="section-title">é¸æŠä¸­</div>
                <div id="selectedType"></div>
                <div id="selectedControls"></div>
                <div class="btn-group" style="margin-top:10px;">
                    <button class="info-btn" id="rotateBtn">ğŸ”„</button>
                    <button class="danger-btn" id="deleteBtn">ğŸ—‘ï¸</button>
                </div>
            </div>
        </div>

        <div class="section">
            <div class="section-title">é¢ç©æƒ…å ±</div>
            <div class="info-box">
                <p><strong>ç·é¢ç©:</strong> <span id="totalArea">0.0</span> ç•³</p>
                <p><strong>éƒ¨å±‹æ•°:</strong> <span id="roomCount">0</span></p>
            </div>
        </div>

        <div class="section">
            <button class="action-btn" id="saveBtn">ğŸ’¾ ä¿å­˜</button>
            <button class="action-btn" id="loadBtn">ğŸ“‚ èª­è¾¼</button>
            <button class="action-btn" id="exportBtn">ğŸ“¥ ç”»åƒ</button>
            <button class="danger-btn" id="clearBtn">ğŸ—‘ï¸ ã‚¯ãƒªã‚¢</button>
        </div>
    </div>

    <div id="canvas-container">
        <canvas id="canvas" width="1400" height="1000"></canvas>
    </div>
    <input type="file" id="fileInput" style="display:none;" accept=".json">

    <!-- Martinez Polygon Clipping Library å¤–éƒ¨ãƒ©ã‚¤ãƒ–ãƒ©ãƒªè¿½åŠ  -->
    <script src="https://cdn.jsdelivr.net/npm/martinez-polygon-clipping@0.7.2/dist/martinez.min.js"></script>

    <script>
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');

// ãƒ­ãƒ¼ã‚«ãƒ«ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸ã‹ã‚‰å¾©å…ƒ
function loadFromStorage() {
    try {
        const saved = localStorage.getItem('floorplan_autosave');
        if (saved) {
            const data = JSON.parse(saved);
            return {
                rooms: data.rooms || [],
                walls: data.walls || [],
                doors: data.doors || [],
                windows: data.windows || [],
                manikins: data.manikins || [],
                dimensions: data.dimensions || [],
                landBoundary: data.landBoundary || null
            };
        }
    } catch (e) {
        console.error('å¾©å…ƒã‚¨ãƒ©ãƒ¼:', e);
    }
    return null;
}

const savedData = loadFromStorage();

let state = {
    rooms: savedData?.rooms || [],
    multiSelectedRooms: [],
    walls: savedData?.walls || [],
    doors: savedData?.doors || [],
    windows: savedData?.windows || [],
    manikins: savedData?.manikins || [],
    dimensions: savedData?.dimensions || [],
    history: [],        // å±¥æ­´
    historyIndex: -1,   // å±¥æ­´ã®ç¾åœ¨ä½ç½®
    landBoundary: savedData?.landBoundary || null,
    selectedTool: 'select', selectedItem: null, selectedVertex: null, selectedEdge: null,
    isDragging: false, 
    isDraggingDoorWindow: false, // ãƒ‰ã‚¢ãƒ»çª“å°‚ç”¨ã®ãƒ‰ãƒ©ãƒƒã‚°ãƒ•ãƒ©ã‚°
    dragStart: null, 
    dragOffset: null,
    wallThickness: 15, gridSize: 45, showGrid: true, scale: 50, zoomLevel: 1.5,
    wallStartVertex: null, tempWallEndPos: null, edgeNormal: null,
    isPanning: false, panOffset: { x: 0, y: 0 },  // ãƒ‘ãƒ³æ©Ÿèƒ½ç”¨
    dimensionStart: null, tempDimensionEnd: null,  // å¯¸æ³•ç·šç”¨
    polygonVertices: [], tempPolygonPos: null  // å¤šè§’å½¢ä½œæˆç”¨
};

//ãƒ‰ã‚¢ãƒ»çª“ã‚’å£ã®è¾ºã«é…ç½®ã™ã‚‹é–¢æ•°
function findNearestEdge(x, y, threshold = 20) {
    let nearest = null;
    let minDist = threshold / state.zoomLevel;
    
    state.rooms.forEach(r => {
        for (let i = 0; i < r.vertices.length; i++) {
            const j = (i + 1) % r.vertices.length;
            const v1 = r.vertices[i];
            const v2 = r.vertices[j];
            const dist = distanceToSegment(x, y, v1.x, v1.y, v2.x, v2.y);
            
            if (dist < minDist) {
                minDist = dist;
                // è¾ºä¸Šã®æœ€è¿‘æ¥ç‚¹ã‚’è¨ˆç®—
                const dx = v2.x - v1.x;
                const dy = v2.y - v1.y;
                const l2 = dx * dx + dy * dy;
                let t = ((x - v1.x) * dx + (y - v1.y) * dy) / l2;
                t = Math.max(0, Math.min(1, t));
                
                const px = v1.x + t * dx;
                const py = v1.y + t * dy;
                const angle = Math.atan2(dy, dx) * 180 / Math.PI;
                
                nearest = {
                    roomId: r.id,
                    edgeIndex: i,
                    x: px,
                    y: py,
                    angle: angle,
                    t: t,  // è¾ºä¸Šã®ä½ç½® (0-1)
                    v1: v1,
                    v2: v2
                };
            }
        }
    });
    
    return nearest;
}

// å®¶å…·ãƒ»è¨­å‚™ãƒ©ã‚¤ãƒ–ãƒ©ãƒª
const furnitureLibrary = {
    kitchen: [
        { name: 'Iå‹ã‚­ãƒƒãƒãƒ³', width: 255, depth: 65, color: '#f5f5dc', icon: 'ğŸ³' },
        { name: 'Lå‹ã‚­ãƒƒãƒãƒ³', width: 255, depth: 180, color: '#f5f5dc', icon: 'ğŸ³', isL: true },
        { name: 'ã‚¢ã‚¤ãƒ©ãƒ³ãƒ‰ã‚­ãƒƒãƒãƒ³', width: 180, depth: 90, color: '#e0e0e0', icon: 'ğŸï¸' },
        { name: 'ã‚·ã‚¹ãƒ†ãƒ ã‚­ãƒƒãƒãƒ³', width: 165, depth: 65, color: '#fff8dc', icon: 'ğŸ´' },
        { name: 'å†·è”µåº«', width: 60, depth: 70, color: '#d3d3d3', icon: 'ğŸ§Š' },
    ],
    bath: [
        { name: 'ãƒ¦ãƒ‹ãƒƒãƒˆãƒã‚¹1216', width: 120, depth: 160, color: '#e6f3ff', icon: 'ğŸ›' },
        { name: 'ãƒ¦ãƒ‹ãƒƒãƒˆãƒã‚¹1616', width: 160, depth: 160, color: '#e6f3ff', icon: 'ğŸ›' },
        { name: 'ãƒ¦ãƒ‹ãƒƒãƒˆãƒã‚¹1620', width: 160, depth: 200, color: '#e6f3ff', icon: 'ğŸ›' },
        { name: 'æ´—é¢å°', width: 75, depth: 60, color: '#ffffff', icon: 'ğŸš°' },
        { name: 'ãƒˆã‚¤ãƒ¬', width: 80, depth: 120, color: '#f0f8ff', icon: 'ğŸš½' },
        { name: 'æ´—æ¿¯æ©Ÿ', width: 60, depth: 60, color: '#f5f5f5', icon: 'ğŸ§º' },
    ],
    furniture: [
        { name: 'ã‚·ãƒ³ã‚°ãƒ«ãƒ™ãƒƒãƒ‰', width: 100, depth: 200, color: '#ffefd5', icon: 'ğŸ›ï¸' },
        { name: 'ãƒ€ãƒ–ãƒ«ãƒ™ãƒƒãƒ‰', width: 140, depth: 200, color: '#ffefd5', icon: 'ğŸ›ï¸' },
        { name: 'ã‚½ãƒ•ã‚¡2äººæ›ã‘', width: 150, depth: 80, color: '#dda0dd', icon: 'ğŸ›‹ï¸' },
        { name: 'ã‚½ãƒ•ã‚¡3äººæ›ã‘', width: 200, depth: 80, color: '#dda0dd', icon: 'ğŸ›‹ï¸' },
        { name: 'ãƒ€ã‚¤ãƒ‹ãƒ³ã‚°ãƒ†ãƒ¼ãƒ–ãƒ«4äºº', width: 120, depth: 80, color: '#deb887', icon: 'ğŸª‘' },
        { name: 'ãƒ€ã‚¤ãƒ‹ãƒ³ã‚°ãƒ†ãƒ¼ãƒ–ãƒ«6äºº', width: 180, depth: 90, color: '#deb887', icon: 'ğŸª‘' },
        { name: 'ãƒ‡ã‚¹ã‚¯', width: 120, depth: 60, color: '#d2b48c', icon: 'ğŸ“' },
        { name: 'ã‚¯ãƒ­ãƒ¼ã‚¼ãƒƒãƒˆ', width: 90, depth: 60, color: '#f4a460', icon: 'ğŸ‘”' },
    ],
    appliance: [
        { name: 'ãƒ†ãƒ¬ãƒ“å°', width: 120, depth: 40, color: '#696969', icon: 'ğŸ“º' },
        { name: 'ã‚¨ã‚¢ã‚³ãƒ³å®¤å†…æ©Ÿ', width: 80, depth: 30, color: '#ffffff', icon: 'â„ï¸' },
    ]
};

// å®¶å…·ãƒªã‚¹ãƒˆã‚’è¡¨ç¤º
function displayFurnitureList(category) {
    const listDiv = document.getElementById('furnitureList');
    const items = furnitureLibrary[category] || [];
    
    listDiv.innerHTML = items.map((item, idx) => `
        <button class="tool-btn" style="text-align: left; padding: 8px; margin-bottom: 4px;" 
                onclick="addFurniture('${category}', ${idx})">
            ${item.icon} ${item.name} (${item.width}Ã—${item.depth}cm)
        </button>
    `).join('');
}

// å®¶å…·ã‚’è¿½åŠ 
function addFurniture(category, index) {
    const item = furnitureLibrary[category][index];
    const scale = state.scale;
    
    // ã‚­ãƒ£ãƒ³ãƒã‚¹ä¸­å¤®ä»˜è¿‘ã«é…ç½®
    const centerX = (canvas.width / state.zoomLevel - state.panOffset.x / state.zoomLevel) / 2;
    const centerY = (canvas.height / state.zoomLevel - state.panOffset.y / state.zoomLevel) / 2;
    
    const w = item.width * scale / 100;
    const d = item.depth * scale / 100;
    
    let vertices;
    if (item.isL) {
        // Lå‹ã‚­ãƒƒãƒãƒ³ç”¨ã®é ‚ç‚¹
        vertices = [
            { x: centerX, y: centerY },
            { x: centerX + w, y: centerY },
            { x: centerX + w, y: centerY + scale * 0.65 },
            { x: centerX + scale * 0.65, y: centerY + scale * 0.65 },
            { x: centerX + scale * 0.65, y: centerY + d },
            { x: centerX, y: centerY + d }
        ];
    } else {
        // é€šå¸¸ã®å››è§’å½¢
        vertices = [
            { x: centerX, y: centerY },
            { x: centerX + w, y: centerY },
            { x: centerX + w, y: centerY + d },
            { x: centerX, y: centerY + d }
        ];
    }
    
    const newRoom = {
        id: Date.now(),
        type: 'room',
        vertices: vertices.map(v => snapPointToGrid(v)),
        name: item.name,
        purpose: category === 'kitchen' ? 'ã‚­ãƒƒãƒãƒ³' : 
                category === 'bath' ? 'æ°´å›ã‚Š' : 
                category === 'furniture' ? 'å®¶å…·' : 'è¨­å‚™',
        color: item.color
    };
    
    state.rooms.push(newRoom);
    state.selectedItem = newRoom;
    saveHistory();
    switchToSelectTool();
    draw();
}

// è‡ªå‹•ä¿å­˜æ©Ÿèƒ½
function autoSave() {
    try {
        const data = {
            rooms: state.rooms,
            walls: state.walls,
            doors: state.doors,
            windows: state.windows,
            manikins: state.manikins,
            dimensions: state.dimensions,
            landBoundary: state.landBoundary
        };
        localStorage.setItem('floorplan_autosave', JSON.stringify(data));
    } catch (e) {
        console.error('è‡ªå‹•ä¿å­˜ã‚¨ãƒ©ãƒ¼:', e);
    }
}

function saveHistory() {
    // ã‚„ã‚Šç›´ã—ç”¨ã®å±¥æ­´ã‚’ã‚¯ãƒªã‚¢
    state.history = state.history.slice(0, state.historyIndex + 1);
    const snapshot = {
        rooms: JSON.parse(JSON.stringify(state.rooms)),
        walls: JSON.parse(JSON.stringify(state.walls)),
        doors: JSON.parse(JSON.stringify(state.doors)),
        windows: JSON.parse(JSON.stringify(state.windows)),
        manikins: JSON.parse(JSON.stringify(state.manikins)),
        dimensions: JSON.parse(JSON.stringify(state.dimensions)),
        landBoundary: state.landBoundary ? JSON.parse(JSON.stringify(state.landBoundary)) : null
    };
    state.history.push(snapshot);
    state.historyIndex++;
    if (state.history.length > 20) {
        state.history.shift();
        state.historyIndex--;
    }
    updateUndoRedoButtons();
    autoSave(); // å±¥æ­´ä¿å­˜æ™‚ã«è‡ªå‹•ä¿å­˜ã‚‚å®Ÿè¡Œ
}

function undo() {
    if (state.historyIndex > 0) {
        state.historyIndex--;
        const snapshot = state.history[state.historyIndex];
        state.rooms = JSON.parse(JSON.stringify(snapshot.rooms));
        state.walls = JSON.parse(JSON.stringify(snapshot.walls));
        state.doors = JSON.parse(JSON.stringify(snapshot.doors));
        state.windows = JSON.parse(JSON.stringify(snapshot.windows));
        state.manikins = JSON.parse(JSON.stringify(snapshot.manikins));
        state.dimensions = JSON.parse(JSON.stringify(snapshot.dimensions));
        state.landBoundary = snapshot.landBoundary ? JSON.parse(JSON.stringify(snapshot.landBoundary)) : null;
        state.selectedItem = null;
        state.selectedVertex = null;
        state.selectedEdge = null;
        updateUndoRedoButtons();
        draw();
    }
}

function redo() {
    if (state.historyIndex < state.history.length - 1) {
        state.historyIndex++;
        const snapshot = state.history[state.historyIndex];
        state.rooms = JSON.parse(JSON.stringify(snapshot.rooms));
        state.walls = JSON.parse(JSON.stringify(snapshot.walls));
        state.doors = JSON.parse(JSON.stringify(snapshot.doors));
        state.windows = JSON.parse(JSON.stringify(snapshot.windows));
        state.manikins = JSON.parse(JSON.stringify(snapshot.manikins));
        state.dimensions = JSON.parse(JSON.stringify(snapshot.dimensions));
        state.landBoundary = snapshot.landBoundary ? JSON.parse(JSON.stringify(snapshot.landBoundary)) : null;
        state.selectedItem = null;
        state.selectedVertex = null;
        state.selectedEdge = null;
        updateUndoRedoButtons();
        draw();
    }
}

function updateUndoRedoButtons() {
    const undoBtn = document.getElementById('undoBtn');
    const redoBtn = document.getElementById('redoBtn');
    
    undoBtn.disabled = state.historyIndex <= 0;
    undoBtn.style.opacity = state.historyIndex <= 0 ? '0.5' : '1';
    
    redoBtn.disabled = state.historyIndex >= state.history.length - 1;
    redoBtn.style.opacity = state.historyIndex >= state.history.length - 1 ? '0.5' : '1';
}

function switchToSelectTool() {
    state.selectedTool = 'select';
    document.querySelectorAll('.tool-btn[data-tool]').forEach(btn => btn.classList.remove('active'));
    document.querySelector('.tool-btn[data-tool="select"]').classList.add('active');
    canvas.style.cursor = 'default';
}

function snapToGrid(v) { const g = state.gridSize * 0.2; return Math.round(v / g) * g; }
// function snapPointToGrid(p) { return { x: snapToGrid(p.x), y: snapToGrid(p.y) }; }
function snapPointToGrid(p) { return { x: snapToGrid(p.x), y: snapToGrid(p.y) }; }

// è¾ºã‚¹ãƒŠãƒƒãƒ—æ©Ÿèƒ½: è¿‘ãã®è¾ºã«å¸ç€
function snapRoomToNearbyEdges(room, threshold = 15) {
    const otherRooms = state.rooms.filter(r => r.id !== room.id);
    if (otherRooms.length === 0) return;
    
    let bestSnap = null;
    let minDistance = threshold;
    
    // ç§»å‹•ä¸­ã®éƒ¨å±‹ã®å„è¾ºã‚’ãƒã‚§ãƒƒã‚¯
    for (let i = 0; i < room.vertices.length; i++) {
        const j = (i + 1) % room.vertices.length;
        const rv1 = room.vertices[i];
        const rv2 = room.vertices[j];
        
        const rEdgeDx = rv2.x - rv1.x;
        const rEdgeDy = rv2.y - rv1.y;
        const rEdgeLen = Math.sqrt(rEdgeDx * rEdgeDx + rEdgeDy * rEdgeDy);
        
        if (rEdgeLen < 0.1) continue;
        
        // ä»–ã®éƒ¨å±‹ã®å„è¾ºã¨ã®è·é›¢ã‚’ãƒã‚§ãƒƒã‚¯
        otherRooms.forEach(otherRoom => {
            for (let oi = 0; oi < otherRoom.vertices.length; oi++) {
                const oj = (oi + 1) % otherRoom.vertices.length;
                const ov1 = otherRoom.vertices[oi];
                const ov2 = otherRoom.vertices[oj];
                
                const oEdgeDx = ov2.x - ov1.x;
                const oEdgeDy = ov2.y - ov1.y;
                const oEdgeLen = Math.sqrt(oEdgeDx * oEdgeDx + oEdgeDy * oEdgeDy);
                
                if (oEdgeLen < 0.1) continue;
                
                // 2ã¤ã®è¾ºãŒå¹³è¡Œã‹ãƒã‚§ãƒƒã‚¯ï¼ˆå†…ç©ã§åˆ¤å®šï¼‰
                const dot = (rEdgeDx * oEdgeDx + rEdgeDy * oEdgeDy) / (rEdgeLen * oEdgeLen);
                const isParallel = Math.abs(Math.abs(dot) - 1) < 0.1; // ã»ã¼å¹³è¡Œ
                
                if (isParallel) {
                    // è¾ºã®ä¸­ç‚¹é–“ã®è·é›¢ã‚’è¨ˆç®—
                    const rMidX = (rv1.x + rv2.x) / 2;
                    const rMidY = (rv1.y + rv2.y) / 2;
                    const oMidX = (ov1.x + ov2.x) / 2;
                    const oMidY = (ov1.y + ov2.y) / 2;
                    
                    // è¾ºã«å‚ç›´ãªæ–¹å‘ã®è·é›¢ã‚’è¨ˆç®—
                    const nx = -oEdgeDy / oEdgeLen;
                    const ny = oEdgeDx / oEdgeLen;
                    
                    const dist = Math.abs((rMidX - oMidX) * nx + (rMidY - oMidY) * ny);
                    
                    if (dist < minDistance) {
                        minDistance = dist;
                        bestSnap = {
                            offset: {
                                x: ((oMidX - rMidX) * nx + (oMidY - rMidY) * ny) * nx,
                                y: ((oMidX - rMidX) * nx + (oMidY - rMidY) * ny) * ny
                            }
                        };
                    }
                }
            }
        });
    }
    
    // ã‚¹ãƒŠãƒƒãƒ—ã‚’é©ç”¨
    if (bestSnap) {
        room.vertices = room.vertices.map(v => ({
            x: v.x + bestSnap.offset.x,
            y: v.y + bestSnap.offset.y
        }));
    }
}

function calculatePolygonArea(vs) {
    let a = 0;
    for (let i = 0; i < vs.length; i++) {
        const j = (i + 1) % vs.length;
        a += vs[i].x * vs[j].y - vs[j].x * vs[i].y;
    }
    return Math.abs(a / 2);
}
function calculateTatamiFromArea(pa) { 
    // 1ç•³ = 910mm Ã— 1820mm = 1.6562mÂ²
    return ((pa / (state.scale * state.scale)) / 1.6562).toFixed(1); 
}
function getTotalArea() {
    // 1ç•³ = 910mm Ã— 1820mm = 1.6562mÂ²
    return (state.rooms.reduce((s, r) => s + calculatePolygonArea(r.vertices) / (state.scale * state.scale), 0) / 1.6562).toFixed(1);
}
function getAllVertices() {
    const vs = [];
    state.rooms.forEach(r => r.vertices.forEach(v => vs.push({ x: v.x, y: v.y, roomId: r.id })));
    return vs;
}
function findNearestVertex(x, y, t = 15) {
    const vs = getAllVertices();
    let n = null, md = t / state.zoomLevel;
    vs.forEach(v => {
        const d = Math.sqrt((x - v.x) ** 2 + (y - v.y) ** 2);
        if (d < md) { md = d; n = v; }
    });
    return n;
}
function calculateDistance(x1, y1, x2, y2) { return Math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2); }
function formatLength(px) {
    const cm = px / state.scale * 100;
    return cm >= 100 ? (cm / 100).toFixed(2) + 'm' : Math.round(cm) + 'cm';
}
function getPolygonCenter(vs) {
    const s = vs.reduce((a, v) => ({ x: a.x + v.x, y: a.y + v.y }), { x: 0, y: 0 });
    return { x: s.x / vs.length, y: s.y / vs.length };
}
function isPointInPolygon(p, vs) {
    let inside = false;
    for (let i = 0, j = vs.length - 1; i < vs.length; j = i++) {
        const xi = vs[i].x, yi = vs[i].y, xj = vs[j].x, yj = vs[j].y;
        if (((yi > p.y) !== (yj > p.y)) && (p.x < (xj - xi) * (p.y - yi) / (yj - yi) + xi)) inside = !inside;
    }
    return inside;
}
function distanceToSegment(px, py, x1, y1, x2, y2) {
    const dx = x2 - x1, dy = y2 - y1, l2 = dx * dx + dy * dy;
    if (l2 === 0) return Math.sqrt((px - x1) ** 2 + (py - y1) ** 2);
    let t = ((px - x1) * dx + (py - y1) * dy) / l2;
    t = Math.max(0, Math.min(1, t));
    const nx = x1 + t * dx, ny = y1 + t * dy;
    return Math.sqrt((px - nx) ** 2 + (py - ny) ** 2);
}
function getEdgeMidpoint(v1, v2) { return { x: (v1.x + v2.x) / 2, y: (v1.y + v2.y) / 2 }; }

// è‰²ã®æ˜ã‚‹ã•èª¿æ•´
function adjustColorBrightness(color, factor) {
    const hex = color.replace('#', '');
    const r = Math.min(255, Math.floor(parseInt(hex.substr(0, 2), 16) * factor));
    const g = Math.min(255, Math.floor(parseInt(hex.substr(2, 2), 16) * factor));
    const b = Math.min(255, Math.floor(parseInt(hex.substr(4, 2), 16) * factor));
    return `#${r.toString(16).padStart(2, '0')}${g.toString(16).padStart(2, '0')}${b.toString(16).padStart(2, '0')}`;
}

// å‡¸åŒ…è¨ˆç®—ï¼ˆGraham Scanï¼‰
function convexHull(points) {
    if (points.length < 3) return points;
    
    points.sort((a, b) => a.x !== b.x ? a.x - b.x : a.y - b.y);
    
    const cross = (o, a, b) => (a.x - o.x) * (b.y - o.y) - (a.y - o.y) * (b.x - o.x);
    
    const lower = [];
    for (let p of points) {
        while (lower.length >= 2 && cross(lower[lower.length - 2], lower[lower.length - 1], p) <= 0) {
            lower.pop();
        }
        lower.push(p);
    }
    
    const upper = [];
    for (let i = points.length - 1; i >= 0; i--) {
        const p = points[i];
        while (upper.length >= 2 && cross(upper[upper.length - 2], upper[upper.length - 1], p) <= 0) {
            upper.pop();
        }
        upper.push(p);
    }
    
    lower.pop();
    upper.pop();
    return lower.concat(upper);
}

// 3ç‚¹ã‹ã‚‰é•·æ–¹å½¢ã‚’ä½œæˆã™ã‚‹é–¢æ•°
function convertTriangleToRectangle(vertices) {
    if (vertices.length !== 3) return vertices;
    
    // 3ç‚¹ã®ãƒã‚¦ãƒ³ãƒ‡ã‚£ãƒ³ã‚°ãƒœãƒƒã‚¯ã‚¹ã‚’è¨ˆç®—
    const minX = Math.min(vertices[0].x, vertices[1].x, vertices[2].x);
    const maxX = Math.max(vertices[0].x, vertices[1].x, vertices[2].x);
    const minY = Math.min(vertices[0].y, vertices[1].y, vertices[2].y);
    const maxY = Math.max(vertices[0].y, vertices[1].y, vertices[2].y);
    
    // é•·æ–¹å½¢ã®4ç‚¹ã‚’è¿”ã™
    return [
        { x: minX, y: minY },
        { x: maxX, y: minY },
        { x: maxX, y: maxY },
        { x: minX, y: maxY }
    ];
}

// ãƒãƒªã‚´ãƒ³åˆæˆ(Martinezä½¿ç”¨)
function unionPolygons(rooms) {
    if (rooms.length === 0) return null;
    
    // å„éƒ¨å±‹ã®ãƒãƒªã‚´ãƒ³ã‚’Martinezå½¢å¼ã«å¤‰æ›
    const polygons = rooms.map(room => {
        const coords = room.vertices.map(v => [v.x, v.y]);
        coords.push(coords[0]); // é–‰ã˜ãŸãƒãƒªã‚´ãƒ³ã«ã™ã‚‹
        return [coords];
    });
    
    try {
        // æœ€åˆã®ãƒãƒªã‚´ãƒ³ã‹ã‚‰é †ã«åˆæˆ
        let result = polygons[0];
        for (let i = 1; i < polygons.length; i++) {
            result = martinez.union(result, polygons[i]);
        }
        
        // çµæœãŒç©ºã®å ´åˆ
        if (!result || result.length === 0) {
            alert('åˆæˆã§ãã¾ã›ã‚“ã§ã—ãŸï¼ˆéƒ¨å±‹ãŒé‡ãªã£ã¦ã„ã¾ã›ã‚“ï¼‰');
            return null;
        }
        
        // Martinezå½¢å¼ã‹ã‚‰é ‚ç‚¹é…åˆ—ã«å¤‰æ›ï¼ˆæœ€ã‚‚å¤§ãã„ãƒãƒªã‚´ãƒ³ã‚’ä½¿ç”¨ï¼‰
        const largestPolygon = result.reduce((max, poly) => {
            return poly[0].length > max[0].length ? poly : max;
        }, result[0]);
        
        const vertices = largestPolygon[0].slice(0, -1).map(coord => ({
            x: coord[0],
            y: coord[1]
        }));
        
        return {
            id: Date.now(),
            type: 'room',
            vertices: vertices,
            name: rooms.map(r => r.name).join('+'),
            purpose: 'åˆæˆéƒ¨å±‹',
            color: rooms[0].color || '#e3f2fd'
        };
    } catch (error) {
        console.error('åˆæˆã‚¨ãƒ©ãƒ¼:', error);
        alert('åˆæˆã«å¤±æ•—ã—ã¾ã—ãŸ');
        return null;
    }
}

// ãƒãƒªã‚´ãƒ³æ¸›ç®—ï¼ˆMartinezä½¿ç”¨ï¼‰
function subtractPolygons(baseRoom, subtractRooms) {
    // ãƒ™ãƒ¼ã‚¹éƒ¨å±‹ã®ãƒãƒªã‚´ãƒ³ã‚’Martinezå½¢å¼ã«å¤‰æ›
    const baseCoords = baseRoom.vertices.map(v => [v.x, v.y]);
    baseCoords.push(baseCoords[0]); // é–‰ã˜ã‚‹
    let result = [baseCoords];
    
    try {
        // å„æ¸›ç®—éƒ¨å±‹ã‚’é †ã«å¼•ã„ã¦ã„ã
        for (let subtractRoom of subtractRooms) {
            const subtractCoords = subtractRoom.vertices.map(v => [v.x, v.y]);
            subtractCoords.push(subtractCoords[0]); // é–‰ã˜ã‚‹
            
            result = martinez.diff(result, [subtractCoords]);
            
            // çµæœãŒç©ºã«ãªã£ãŸå ´åˆã¯çµ‚äº†
            if (!result || result.length === 0) {
                alert('æ¸›ç®—ã®çµæœã€éƒ¨å±‹ãŒãªããªã‚Šã¾ã—ãŸ');
                return null;
            }
        }
        
        // Martinezå½¢å¼ã‹ã‚‰é ‚ç‚¹é…åˆ—ã«å¤‰æ›ï¼ˆæœ€ã‚‚å¤§ãã„ãƒãƒªã‚´ãƒ³ã‚’ä½¿ç”¨ï¼‰
        const largestPolygon = result.reduce((max, poly) => {
            return poly[0].length > max[0].length ? poly : max;
        }, result[0]);
        
        const vertices = largestPolygon[0].slice(0, -1).map(coord => ({
            x: coord[0],
            y: coord[1]
        }));
        
        return {
            id: Date.now(),
            type: 'room',
            vertices: vertices,
            name: baseRoom.name + ' (æ¸›ç®—å¾Œ)',
            purpose: baseRoom.purpose,
            color: baseRoom.color
        };
    } catch (error) {
        console.error('æ¸›ç®—ã‚¨ãƒ©ãƒ¼:', error);
        alert('æ¸›ç®—ã«å¤±æ•—ã—ã¾ã—ãŸ');
        return null;
    }
}

// å¯¸æ³•ç·šã®å®Ÿéš›ã®åº§æ¨™ã‚’å–å¾—ï¼ˆå‚ç…§å…ˆã®ç¾åœ¨ä½ç½®ã‚’åæ˜ ï¼‰
function getDimensionCoords(dim) {
    const getPointCoords = (ref) => {
        if (ref.type === 'vertex') {
            const room = state.rooms.find(r => r.id === ref.roomId);
            if (room && room.vertices[ref.vertexIndex]) {
                return { x: room.vertices[ref.vertexIndex].x, y: room.vertices[ref.vertexIndex].y };
            }
        } else if (ref.type === 'edge') {
            const room = state.rooms.find(r => r.id === ref.roomId);
            if (room) {
                const v1 = room.vertices[ref.edgeIndex];
                const v2 = room.vertices[(ref.edgeIndex + 1) % room.vertices.length];
                if (v1 && v2) {
                    return getEdgeMidpoint(v1, v2);
                }
            }
        }
         else if (ref.type === 'wall-vertex') {
            const wall = state.walls.find(w => w.id === ref.wallId);
            if (wall) {
                return ref.endpoint === 1 ? { x: wall.x1, y: wall.y1 } : { x: wall.x2, y: wall.y2 };
            }
        } else if (ref.type === 'wall-midpoint') {
            const wall = state.walls.find(w => w.id === ref.wallId);
            if (wall) {
                return { x: (wall.x1 + wall.x2) / 2, y: (wall.y1 + wall.y2) / 2 };
            }
        } else if (ref.type === 'point') {
            return { x: ref.x, y: ref.y };
        }
        return null;
    };
    
    const p1 = getPointCoords(dim.start);
    const p2 = getPointCoords(dim.end);
    
    return (p1 && p2) ? { p1, p2 } : null;
}

// ã‚­ãƒ£ãƒ³ãƒã‚¹ã‚µã‚¤ã‚ºã®èª¿æ•´
function resizeCanvas() {
    const container = document.getElementById('canvas-container');
    const rect = container.getBoundingClientRect();
    if (window.innerWidth <= 768) {
        canvas.width = rect.width - 20;
        canvas.height = rect.height - 20;
    } else {
        canvas.width = 1400;
        canvas.height = 1000;
    }
    draw();
}

window.addEventListener('resize', resizeCanvas);
window.addEventListener('load', resizeCanvas);

// éƒ¨å±‹ã«é–¢é€£ã™ã‚‹å¯¸æ³•ç·šã®æ•°ã‚’æ•°ãˆã‚‹
function countRoomDimensions(roomId) {
    return state.dimensions.filter(dim => dim.roomId === roomId).length;
}

// éƒ¨å±‹ã®å¯¸æ³•ç·šã‚’è‡ªå‹•è¿½åŠ /å‰Šé™¤
function toggleRoomDimensions(roomId) {
    const room = state.rooms.find(r => r.id === roomId);
    if (!room) return;
    
    const existingDimCount = countRoomDimensions(roomId);
    
    if (existingDimCount > 0) {
        // æ—¢ã«å¯¸æ³•ç·šãŒã‚ã‚‹å ´åˆã¯å‰Šé™¤
        state.dimensions = state.dimensions.filter(dim => dim.roomId !== roomId);
    } else {
        // å¯¸æ³•ç·šã‚’è‡ªå‹•è¿½åŠ 
        const vertices = room.vertices;
        
        if (vertices.length === 4) {
            // å››è§’å½¢ã®å ´åˆ: ä¸Šä¸‹ã¨å·¦å³ã®å†…éƒ¨å¯¸æ³•
            // æ¨ªå¹…ï¼ˆä¸Šè¾ºã¨ä¸‹è¾ºï¼‰
            state.dimensions.push({
                id: Date.now() + 1,
                type: 'dimension',
                start: { type: 'vertex', roomId: roomId, vertexIndex: 0 },
                end: { type: 'vertex', roomId: roomId, vertexIndex: 1 },
                offset: -30,
                roomId: roomId
            });
            state.dimensions.push({
                id: Date.now() + 2,
                type: 'dimension',
                start: { type: 'vertex', roomId: roomId, vertexIndex: 2 },
                end: { type: 'vertex', roomId: roomId, vertexIndex: 3 },
                offset: 30,
                roomId: roomId
            });
            
            // ç¸¦å¹…ï¼ˆå·¦è¾ºã¨å³è¾ºï¼‰
            state.dimensions.push({
                id: Date.now() + 3,
                type: 'dimension',
                start: { type: 'vertex', roomId: roomId, vertexIndex: 0 },
                end: { type: 'vertex', roomId: roomId, vertexIndex: 3 },
                offset: -30,
                roomId: roomId
            });
            state.dimensions.push({
                id: Date.now() + 4,
                type: 'dimension',
                start: { type: 'vertex', roomId: roomId, vertexIndex: 1 },
                end: { type: 'vertex', roomId: roomId, vertexIndex: 2 },
                offset: 30,
                roomId: roomId
            });
        } else if (vertices.length === 6) {
            // Lå‹ã¾ãŸã¯ãã®ä»–6è§’å½¢: å…¨ã¦ã®è¾ºã«å¯¸æ³•ç·š
            for (let i = 0; i < vertices.length; i++) {
                const j = (i + 1) % vertices.length;
                state.dimensions.push({
                    id: Date.now() + i + 1,
                    type: 'dimension',
                    start: { type: 'vertex', roomId: roomId, vertexIndex: i },
                    end: { type: 'vertex', roomId: roomId, vertexIndex: j },
                    offset: 30,
                    roomId: roomId
                });
            }
        } else {
            // ãã®ä»–ã®å½¢çŠ¶: å…¨ã¦ã®è¾ºã«å¯¸æ³•ç·šã‚’è¿½åŠ 
            for (let i = 0; i < vertices.length; i++) {
                const j = (i + 1) % vertices.length;
                state.dimensions.push({
                    id: Date.now() + i + 1,
                    type: 'dimension',
                    start: { type: 'vertex', roomId: roomId, vertexIndex: i },
                    end: { type: 'vertex', roomId: roomId, vertexIndex: j },
                    offset: 30,
                    roomId: roomId
                });
            }
        }
    }
    
    saveHistory();
    draw();
}

function draw() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    ctx.save();
    ctx.translate(state.panOffset.x, state.panOffset.y);
    ctx.scale(state.zoomLevel, state.zoomLevel);

    //ã‚°ãƒªãƒƒãƒ‰æç”»
    if (state.showGrid) {
        ctx.strokeStyle = '#e0e0e0';
        ctx.lineWidth = 0.5 / state.zoomLevel;
        const g = state.gridSize * 0.2;
        
        // æ•·åœ°ç¯„å›²ãŒè¨­å®šã•ã‚Œã¦ã„ã‚‹å ´åˆã¯ãã®ç¯„å›²ã®ã¿ã«ã‚°ãƒªãƒƒãƒ‰ã‚’è¡¨ç¤º
        if (state.landBoundary) {
            const startX = state.landBoundary.x;
            const endX = state.landBoundary.x + state.landBoundary.width;
            const startY = state.landBoundary.y;
            const endY = state.landBoundary.y + state.landBoundary.height;
            
            for (let x = startX; x <= endX; x += g) {
                ctx.beginPath();
                ctx.moveTo(x, startY);
                ctx.lineTo(x, endY);
                ctx.stroke();
            }
            for (let y = startY; y <= endY; y += g) {
                ctx.beginPath();
                ctx.moveTo(startX, y);
                ctx.lineTo(endX, y);
                ctx.stroke();
            }
        } else {
            // æ•·åœ°ç¯„å›²ãŒæœªè¨­å®šã®å ´åˆã¯ã‚­ãƒ£ãƒ³ãƒã‚¹å…¨ä½“ã«ã‚°ãƒªãƒƒãƒ‰è¡¨ç¤º
            for (let x = 0; x < canvas.width / state.zoomLevel; x += g) {
                ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, canvas.height / state.zoomLevel); ctx.stroke();
            }
            for (let y = 0; y < canvas.height / state.zoomLevel; y += g) {
                ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(canvas.width / state.zoomLevel, y); ctx.stroke();
            }
        }
    }

    // æ•·åœ°ç¯„å›²ã®æç”»
    if (state.landBoundary) {
        console.log('æ•·åœ°ç¯„å›²ã‚’æç”»:', state.landBoundary);  // â† ãƒ‡ãƒãƒƒã‚°è¿½åŠ 
        ctx.strokeStyle = '#ff5722';
        ctx.lineWidth = 3 / state.zoomLevel;
        ctx.setLineDash([10 / state.zoomLevel, 5 / state.zoomLevel]);
        ctx.strokeRect(
            state.landBoundary.x,
            state.landBoundary.y,
            state.landBoundary.width,
            state.landBoundary.height
        );
        ctx.setLineDash([]);
        
        // ã‚µã‚¤ã‚ºè¡¨ç¤º
        ctx.fillStyle = '#ff5722';
        ctx.font = `bold ${14 / state.zoomLevel}px sans-serif`;
        ctx.textAlign = 'center';
        ctx.fillText(
            `${(state.landBoundary.width / state.scale).toFixed(1)}m Ã— ${(state.landBoundary.height / state.scale).toFixed(1)}m`,
            state.landBoundary.x + state.landBoundary.width / 2,
            state.landBoundary.y - 10 / state.zoomLevel
        );
    }

state.rooms.forEach(r => {
    const sel = state.selectedItem?.id === r.id;
    const multiSel = state.multiSelectedRooms.includes(r.id);
    
    // å¡—ã‚Šã¤ã¶ã—è‰²ã®è¨­å®š
    if (multiSel) {
        ctx.fillStyle = adjustColorBrightness(r.color || '#e3f2fd', 1.2);
    } else {
        ctx.fillStyle = r.color || '#e3f2fd';
    }
    
    ctx.beginPath();
    ctx.moveTo(r.vertices[0].x, r.vertices[0].y);
    for (let i = 1; i < r.vertices.length; i++) ctx.lineTo(r.vertices[i].x, r.vertices[i].y);
    ctx.closePath();
    ctx.fill();
    
    // æ ç·šã®è¨­å®š
    ctx.strokeStyle = sel ? '#2196f3' : (multiSel ? '#4caf50' : '#666');
    ctx.lineWidth = (sel || multiSel ? 3 : 1) / state.zoomLevel;
    ctx.stroke();

    r.vertices.forEach((v, idx) => {
        const sv = state.selectedVertex?.roomId === r.id && state.selectedVertex?.index === idx;
        ctx.fillStyle = sv ? '#f44336' : '#2196f3';
        const h = 8 / state.zoomLevel;
        ctx.fillRect(v.x - h/2, v.y - h/2, h, h);
    });

        if ((state.selectedTool === 'add-vertex' || state.selectedTool === 'edit-edge') && sel) {
            for (let i = 0; i < r.vertices.length; i++) {
                const j = (i + 1) % r.vertices.length;
                const se = state.selectedEdge?.roomId === r.id && state.selectedEdge?.index === i;
                ctx.strokeStyle = se ? '#f44336' : '#ff9800';
                ctx.lineWidth = 3 / state.zoomLevel;
                ctx.setLineDash([5 / state.zoomLevel, 5 / state.zoomLevel]);
                ctx.beginPath();
                ctx.moveTo(r.vertices[i].x, r.vertices[i].y);
                ctx.lineTo(r.vertices[j].x, r.vertices[j].y);
                ctx.stroke();
                
                if (state.selectedTool === 'edit-edge') {
                    const m = getEdgeMidpoint(r.vertices[i], r.vertices[j]);
                    ctx.fillStyle = se ? '#f44336' : '#ff9800';
                    const h = 10 / state.zoomLevel;
                    ctx.fillRect(m.x - h/2, m.y - h/2, h, h);
                }
            }
            ctx.setLineDash([]);
        }

        const c = getPolygonCenter(r.vertices);
        ctx.fillStyle = '#333';
        ctx.font = `bold ${16 / state.zoomLevel}px sans-serif`;
        ctx.textAlign = 'center';
        ctx.fillText(r.name || 'éƒ¨å±‹', c.x, c.y - 15 / state.zoomLevel);
        ctx.font = `${14 / state.zoomLevel}px sans-serif`;
        ctx.fillText(calculateTatamiFromArea(calculatePolygonArea(r.vertices)) + 'ç•³', c.x, c.y + 5 / state.zoomLevel);
        if (r.purpose) {
            ctx.font = `${12 / state.zoomLevel}px sans-serif`;
            ctx.fillStyle = '#666';
            ctx.fillText(r.purpose, c.x, c.y + 22 / state.zoomLevel);
        }
    });

    state.walls.forEach(w => {
        const sel = state.selectedItem?.id === w.id;
        ctx.strokeStyle = sel ? '#2196f3' : '#333';
        ctx.lineWidth = w.thickness / state.zoomLevel;
        ctx.lineCap = 'square';
        ctx.beginPath();
        ctx.moveTo(w.x1, w.y1);
        ctx.lineTo(w.x2, w.y2);
        ctx.stroke();
        
        const mx = (w.x1 + w.x2) / 2, my = (w.y1 + w.y2) / 2;
        ctx.fillStyle = '#333';
        ctx.font = `${12 / state.zoomLevel}px sans-serif`;
        ctx.textAlign = 'center';
        ctx.fillText(formatLength(calculateDistance(w.x1, w.y1, w.x2, w.y2)), mx, my - 10 / state.zoomLevel);
        
        if (sel) {
            ctx.fillStyle = '#2196f3';
            const h = 8 / state.zoomLevel;
            ctx.fillRect(w.x1 - h/2, w.y1 - h/2, h, h);
            ctx.fillRect(w.x2 - h/2, w.y2 - h/2, h, h);
            ctx.fillStyle = '#ff9800';
            ctx.beginPath();
            ctx.arc(mx, my, 6 / state.zoomLevel, 0, Math.PI * 2);
            ctx.fill();
        }
    });

    if (state.selectedTool === 'wall' && state.wallStartVertex && state.tempWallEndPos) {
        ctx.strokeStyle = '#ff9800';
        ctx.lineWidth = 2 / state.zoomLevel;
        ctx.setLineDash([5 / state.zoomLevel, 5 / state.zoomLevel]);
        ctx.beginPath();
        ctx.moveTo(state.wallStartVertex.x, state.wallStartVertex.y);
        ctx.lineTo(state.tempWallEndPos.x, state.tempWallEndPos.y);
        ctx.stroke();
        ctx.setLineDash([]);
        
        const mx = (state.wallStartVertex.x + state.tempWallEndPos.x) / 2;
        const my = (state.wallStartVertex.y + state.tempWallEndPos.y) / 2;
        ctx.fillStyle = '#ff9800';
        ctx.font = `bold ${12 / state.zoomLevel}px sans-serif`;
        ctx.textAlign = 'center';
        ctx.fillText(formatLength(calculateDistance(state.wallStartVertex.x, state.wallStartVertex.y, state.tempWallEndPos.x, state.tempWallEndPos.y)), mx, my - 10 / state.zoomLevel);
    }

    state.doors.forEach(d => {
        const sel = state.selectedItem?.id === d.id;
        
        // è¾ºä¸Šã®ä½ç½®ã‚’è¨ˆç®—
        const room = state.rooms.find(r => r.id === d.roomId);
        if (!room) return;
        
        const v1 = room.vertices[d.edgeIndex];
        const v2 = room.vertices[(d.edgeIndex + 1) % room.vertices.length];
        const dx = v2.x - v1.x;
        const dy = v2.y - v1.y;
        
        const x = v1.x + d.t * dx;
        const y = v1.y + d.t * dy;
        const angle = Math.atan2(dy, dx);
        
        ctx.save();
        ctx.translate(x, y);
        ctx.rotate(angle);
        const lw = 4 / state.zoomLevel;
        if (d.doorType === 'swing') {
            ctx.strokeStyle = sel ? '#2196f3' : '#8b4513';
            ctx.lineWidth = lw;
            
            // å·¦å³åè»¢ã®å ´åˆã¯åº§æ¨™ã‚’åè»¢
            if (d.flippedHorizontal) {
                ctx.scale(-1, 1);
                ctx.translate(-d.width, 0);
            }
            
            ctx.beginPath();
            ctx.moveTo(0, 0);
            ctx.lineTo(d.width, 0);
            ctx.stroke();
            ctx.strokeStyle = '#ccc';
            ctx.lineWidth = 1 / state.zoomLevel;
            ctx.beginPath();
            
            // flippedãƒ•ãƒ©ã‚°ã§é–‹ãæ–¹å‘ã‚’åè»¢ï¼ˆéƒ¨å±‹ã®å†…å´/å¤–å´ï¼‰
            if (d.flipped) {
                ctx.arc(0, 0, d.width, -Math.PI/2, 0); // ä¸‹å‘ãã«é–‹ã
            } else {
                ctx.arc(0, 0, d.width, 0, Math.PI/2);  // ä¸Šå‘ãã«é–‹ã
            }
            ctx.stroke();
        } else {
            ctx.strokeStyle = sel ? '#2196f3' : '#8b4513';
            ctx.lineWidth = lw;
            ctx.beginPath();
            ctx.moveTo(0, -5);
            ctx.lineTo(d.width/2, -5);
            ctx.moveTo(d.width/2, 5);
            ctx.lineTo(d.width, 5);
            ctx.stroke();
        }
        ctx.restore();
    });

    state.windows.forEach(w => {
        const sel = state.selectedItem?.id === w.id;
        
        // è¾ºä¸Šã®ä½ç½®ã‚’è¨ˆç®—
        const room = state.rooms.find(r => r.id === w.roomId);
        if (!room) return;
        
        const v1 = room.vertices[w.edgeIndex];
        const v2 = room.vertices[(w.edgeIndex + 1) % room.vertices.length];
        const dx = v2.x - v1.x;
        const dy = v2.y - v1.y;
        
        const x = v1.x + w.t * dx;
        const y = v1.y + w.t * dy;
        const angle = Math.atan2(dy, dx);
        
        ctx.save();
        ctx.translate(x, y);
        ctx.rotate(angle);
        ctx.strokeStyle = sel ? '#2196f3' : '#4fc3f7';
        ctx.lineWidth = 5 / state.zoomLevel;
        ctx.beginPath();
        ctx.moveTo(0, 0);
        ctx.lineTo(w.width, 0);
        ctx.stroke();
        ctx.strokeStyle = '#b3e5fc';
        ctx.lineWidth = 2 / state.zoomLevel;
        ctx.beginPath();
        ctx.moveTo(w.width/2, -4);
        ctx.lineTo(w.width/2, 4);
        ctx.stroke();
        ctx.restore();
    });

    state.manikins.forEach(m => {
        const sel = state.selectedItem?.id === m.id;
        ctx.save();
        ctx.translate(m.x, m.y);
        ctx.rotate((m.rotation * Math.PI) / 180);
        const s = 20 / state.zoomLevel;
        ctx.strokeStyle = sel ? '#2196f3' : '#ff5722';
        ctx.fillStyle = '#ffccbc';
        ctx.lineWidth = 2 / state.zoomLevel;
        ctx.beginPath();
        ctx.arc(0, -s, s/3, 0, Math.PI * 2);
        ctx.fill();
        ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(0, -s * 0.7);
        ctx.lineTo(0, s * 0.5);
        ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(-s/2, -s * 0.3);
        ctx.lineTo(0, -s * 0.5);
        ctx.lineTo(s/2, -s * 0.3);
        ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(0, s * 0.5);
        ctx.lineTo(-s/3, s * 1.2);
        ctx.moveTo(0, s * 0.5);
        ctx.lineTo(s/3, s * 1.2);
        ctx.stroke();
        ctx.restore();
    });

    // å¯¸æ³•ç·šã®æç”»
    state.dimensions.forEach(dim => {
        const coords = getDimensionCoords(dim);
        if (!coords) return;
        
        const { p1, p2 } = coords;
        const sel = state.selectedItem?.id === dim.id;
        
        // è¾ºã®æ–¹å‘ã‚’å–å¾—ã™ã‚‹é–¢æ•°
        const getEdgeDirection = (ref) => {
            if (ref.type === 'edge') {
                const room = state.rooms.find(r => r.id === ref.roomId);
                if (room) {
                    const v1 = room.vertices[ref.edgeIndex];
                    const v2 = room.vertices[(ref.edgeIndex + 1) % room.vertices.length];
                    const dx = v2.x - v1.x;
                    const dy = v2.y - v1.y;
                    const len = Math.sqrt(dx * dx + dy * dy);
                    return { dx: dx / len, dy: dy / len, angle: Math.atan2(dy, dx) };
                }
            } else if (ref.type === 'wall-midpoint') {
                const wall = state.walls.find(w => w.id === ref.wallId);
                if (wall) {
                    const dx = wall.x2 - wall.x1;
                    const dy = wall.y2 - wall.y1;
                    const len = Math.sqrt(dx * dx + dy * dy);
                    return { dx: dx / len, dy: dy / len, angle: Math.atan2(dy, dx) };
                }
            }
            return null;
        };
        
        const startEdge = getEdgeDirection(dim.start);
        const endEdge = getEdgeDirection(dim.end);
        
        let ox1, oy1, ox2, oy2, length, angle;
        
        // è¾ºãŒå«ã¾ã‚Œã‚‹å ´åˆã¯ã€è¾ºã«å¹³è¡Œãªå¯¸æ³•ç·šã‚’å¼•ã
        if (startEdge || endEdge) {
            // è¾ºã®æ–¹å‘ã‚’æ±ºå®šï¼ˆå§‹ç‚¹ãŒè¾ºãªã‚‰å§‹ç‚¹ã€çµ‚ç‚¹ãŒè¾ºãªã‚‰çµ‚ç‚¹ï¼‰
            const refEdge = startEdge || endEdge;
            angle = refEdge.angle;
            const edgeDx = refEdge.dx;
            const edgeDy = refEdge.dy;
            
            // ä¸¡æ–¹ãŒè¾ºã®å ´åˆã¯ã€è¾ºã¨è¾ºã®é–“ã®è·é›¢ã‚’æ¸¬å®š
            if (startEdge && endEdge) {
                // å®Ÿéš›ã«ã‚¯ãƒªãƒƒã‚¯ã—ãŸä½ç½®ï¼ˆè¾ºä¸Šã®ç‚¹ï¼‰ã‚’ä½¿ç”¨
                const edge1Point = p1;
                const edge2Point = p2;
                
                // è¾ºã®æ–¹å‘ã‚’åˆ¤å®šï¼ˆæ°´å¹³å¯„ã‚Šã‹å‚ç›´å¯„ã‚Šã‹ï¼‰
                const isHorizontal = Math.abs(edgeDx) > Math.abs(edgeDy);
                
                // 2ç‚¹é–“ã®è·é›¢
                const dx = edge2Point.x - edge1Point.x;
                const dy = edge2Point.y - edge1Point.y;
                
                if (isHorizontal) {
                    // è¾ºãŒæ°´å¹³å¯„ã‚Š â†’ å‚ç›´æ–¹å‘ã®è·é›¢ã‚’æ¸¬å®š
                    length = Math.abs(dy);
                    angle = Math.PI / 2; // å‚ç›´
                    const offsetDist = dim.offset || 30;
                    ox1 = edge1Point.x + offsetDist;
                    oy1 = edge1Point.y;
                    ox2 = edge1Point.x + offsetDist;
                    oy2 = edge2Point.y;
                 } else {
                    // è¾ºãŒå‚ç›´å¯„ã‚Š â†’ æ°´å¹³æ–¹å‘ã®è·é›¢ã‚’æ¸¬å®š
                    length = Math.abs(dx);
                    angle = 0; // æ°´å¹³
                    const offsetDist = dim.offset || 30;
                    ox1 = edge1Point.x;
                    oy1 = edge1Point.y + offsetDist;
                    ox2 = edge2Point.x;
                    oy2 = edge1Point.y + offsetDist;
                }
            }else{
                // ç‰‡æ–¹ãŒè¾ºã€ç‰‡æ–¹ãŒç‚¹ã®å ´åˆã¯ã€è¾ºã«å¹³è¡Œãªè·é›¢
                const vecX = p2.x - p1.x;
                const vecY = p2.y - p1.y;
                const projLength = vecX * edgeDx + vecY * edgeDy;
                
                // è¾ºã«å¹³è¡Œãªå¯¸æ³•ç·šã®é•·ã•
                length = Math.abs(projLength);
                
                // æ³•ç·šæ–¹å‘
                const offsetDist = dim.offset || 30;
                const nx = -edgeDy;
                const ny = edgeDx;
                
                // å¯¸æ³•ç·šã®ä¸¡ç«¯
                ox1 = p1.x + nx * offsetDist;
                oy1 = p1.y + ny * offsetDist;
                ox2 = ox1 + edgeDx * projLength;
                oy2 = oy1 + edgeDy * projLength;
            }
        } else {
            // ç‰‡æ–¹ã¾ãŸã¯ä¸¡æ–¹ãŒç‚¹ã®å ´åˆã¯ã€é€šå¸¸ã®å¯¸æ³•ç·š
            const dx = p2.x - p1.x;
            const dy = p2.y - p1.y;
            length = Math.sqrt(dx * dx + dy * dy);
            
            if (length < 0.1) return;
            
            angle = Math.atan2(dy, dx);
            const offsetDist = dim.offset || 30;
            const nx = -dy / length;
            const ny = dx / length;
            
            ox1 = p1.x + nx * offsetDist;
            oy1 = p1.y + ny * offsetDist;
            ox2 = p2.x + nx * offsetDist;
            oy2 = p2.y + ny * offsetDist;
        }
        
        if (length < 0.1) return;
        ctx.strokeStyle = sel ? '#2196f3' : '#666';
        ctx.lineWidth = 1 / state.zoomLevel;
        
        ctx.setLineDash([3 / state.zoomLevel, 3 / state.zoomLevel]);
        ctx.beginPath();
        ctx.moveTo(p1.x, p1.y);
        ctx.lineTo(ox1, oy1);
        ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(p2.x, p2.y);
        ctx.lineTo(ox2, oy2);
        ctx.stroke();
        ctx.setLineDash([]);
        
        ctx.lineWidth = 1.5 / state.zoomLevel;
        ctx.beginPath();
        ctx.moveTo(ox1, oy1);
        ctx.lineTo(ox2, oy2);
        ctx.stroke();
        
        const arrowSize = 6 / state.zoomLevel;
        
        ctx.beginPath();
        ctx.moveTo(ox1, oy1);
        ctx.lineTo(ox1 + arrowSize * Math.cos(angle + Math.PI * 0.85), oy1 + arrowSize * Math.sin(angle + Math.PI * 0.85));
        ctx.moveTo(ox1, oy1);
        ctx.lineTo(ox1 + arrowSize * Math.cos(angle - Math.PI * 0.85), oy1 + arrowSize * Math.sin(angle - Math.PI * 0.85));
        ctx.stroke();
        
        ctx.beginPath();
        ctx.moveTo(ox2, oy2);
        ctx.lineTo(ox2 - arrowSize * Math.cos(angle + Math.PI * 0.85), oy2 - arrowSize * Math.sin(angle + Math.PI * 0.85));
        ctx.moveTo(ox2, oy2);
        ctx.lineTo(ox2 - arrowSize * Math.cos(angle - Math.PI * 0.85), oy2 - arrowSize * Math.sin(angle - Math.PI * 0.85));
        ctx.stroke();
        
        const mx = (ox1 + ox2) / 2;
        const my = (oy1 + oy2) / 2;
        
        ctx.save();
        ctx.translate(mx, my);
        ctx.rotate(angle);
        
        const text = formatLength(length);
        ctx.font = `bold ${12 / state.zoomLevel}px sans-serif`;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        const metrics = ctx.measureText(text);
        const padding = 3 / state.zoomLevel;
        
        ctx.fillStyle = 'white';
        ctx.fillRect(-metrics.width / 2 - padding, -7 / state.zoomLevel, metrics.width + padding * 2, 14 / state.zoomLevel);
        
        ctx.fillStyle = sel ? '#2196f3' : '#333';
        ctx.fillText(text, 0, 0);
        
        ctx.restore();
    });

        // å¯¸æ³•ç·šä½œæˆä¸­ã®ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼
    if (state.selectedTool === 'dimension' && state.dimensionStart && state.tempDimensionEnd) {
        const p1 = state.dimensionStart;
        const p2 = state.tempDimensionEnd;
        
        const dx = p2.x - p1.x;
        const dy = p2.y - p1.y;
        const length = Math.sqrt(dx * dx + dy * dy);
        
        ctx.strokeStyle = '#ff9800';
        ctx.lineWidth = 2 / state.zoomLevel;
        ctx.setLineDash([5 / state.zoomLevel, 5 / state.zoomLevel]);
        ctx.beginPath();
        ctx.moveTo(p1.x, p1.y);
        ctx.lineTo(p2.x, p2.y);
        ctx.stroke();
        ctx.setLineDash([]);
        
        ctx.fillStyle = '#ff9800';
        ctx.font = `bold ${12 / state.zoomLevel}px sans-serif`;
        ctx.textAlign = 'center';
        ctx.fillText(formatLength(length), (p1.x + p2.x) / 2, (p1.y + p2.y) / 2 - 10 / state.zoomLevel);
    }

    // å¤šè§’å½¢ä½œæˆä¸­ã®ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼
    if (state.selectedTool === 'polygon' && state.polygonVertices.length > 0) {
        ctx.strokeStyle = '#ff9800';
        ctx.fillStyle = 'rgba(255, 152, 0, 0.1)';
        ctx.lineWidth = 2 / state.zoomLevel;
        ctx.setLineDash([5 / state.zoomLevel, 5 / state.zoomLevel]);
        
        ctx.beginPath();
        ctx.moveTo(state.polygonVertices[0].x, state.polygonVertices[0].y);
        for (let i = 1; i < state.polygonVertices.length; i++) {
            ctx.lineTo(state.polygonVertices[i].x, state.polygonVertices[i].y);
        }
        if (state.tempPolygonPos) {
            ctx.lineTo(state.tempPolygonPos.x, state.tempPolygonPos.y);
        }
        if (state.polygonVertices.length > 2 && state.tempPolygonPos) {
            ctx.lineTo(state.polygonVertices[0].x, state.polygonVertices[0].y);
        }
        ctx.stroke();
        ctx.fill();
        ctx.setLineDash([]);
        
        // é ‚ç‚¹ã‚’æç”»
        state.polygonVertices.forEach((v, idx) => {
            ctx.fillStyle = idx === 0 ? '#4caf50' : '#ff9800';
            const h = 8 / state.zoomLevel;
            ctx.fillRect(v.x - h/2, v.y - h/2, h, h);
        });
        
        // ã‚¹ãƒŠãƒƒãƒ—ä¸­ã®æ—¢å­˜é ‚ç‚¹ã‚’ãƒã‚¤ãƒ©ã‚¤ãƒˆ
        if (state.tempPolygonPos) {
            const nearestVertex = findNearestVertex(state.tempPolygonPos.x, state.tempPolygonPos.y, 20);
            if (nearestVertex) {
                ctx.strokeStyle = '#4caf50';
                ctx.lineWidth = 3 / state.zoomLevel;
                ctx.beginPath();
                ctx.arc(nearestVertex.x, nearestVertex.y, 12 / state.zoomLevel, 0, Math.PI * 2);
                ctx.stroke();
            }
        }
        
       // å®Œäº†å¯èƒ½ãªå ´åˆã®è¡¨ç¤º
        if (state.polygonVertices.length >= 3 && state.tempPolygonPos) {
            const firstV = state.polygonVertices[0];
            const distToFirst = Math.sqrt((state.tempPolygonPos.x - firstV.x) ** 2 + (state.tempPolygonPos.y - firstV.y) ** 2);
            const isInsidePolygon = isPointInPolygon(state.tempPolygonPos, state.polygonVertices);
            
            // æœ€åˆã®ç‚¹ã«è¿‘ã„ã‹ã€å†…éƒ¨ã«ã‚ã‚‹å ´åˆ
            if (distToFirst < 15 / state.zoomLevel) {
                // æœ€åˆã®ç‚¹ã«è¿‘ã„å ´åˆ
                ctx.fillStyle = '#4caf50';
                ctx.beginPath();
                ctx.arc(firstV.x, firstV.y, 12 / state.zoomLevel, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.fillStyle = 'white';
                ctx.font = `bold ${10 / state.zoomLevel}px sans-serif`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                const text = state.polygonVertices.length === 3 ? 'â–¡' : 'å®Œäº†';
                ctx.fillText(text, firstV.x, firstV.y);
            } else if (isInsidePolygon) {
                // å†…éƒ¨ã‚’ã‚¯ãƒªãƒƒã‚¯å¯èƒ½ãªå ´åˆ
                const center = getPolygonCenter(state.polygonVertices);
                ctx.fillStyle = 'rgba(76, 175, 80, 0.3)';
                ctx.beginPath();
                ctx.arc(center.x, center.y, 20 / state.zoomLevel, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.fillStyle = '#4caf50';
                ctx.font = `bold ${12 / state.zoomLevel}px sans-serif`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                const text = state.polygonVertices.length === 3 ? 'â–¡ç¢ºå®š' : 'âœ“ç¢ºå®š';
                ctx.fillText(text, center.x, center.y);
            }
        }
        
        // æœ€å¾Œã®ç‚¹ã‚’å†åº¦ã‚¯ãƒªãƒƒã‚¯ã§ã‚­ãƒ£ãƒ³ã‚»ãƒ«å¯èƒ½ã‚’è¡¨ç¤º
        if (state.polygonVertices.length > 0 && state.tempPolygonPos) {
            const lastV = state.polygonVertices[state.polygonVertices.length - 1];
            const distToLast = Math.sqrt((state.tempPolygonPos.x - lastV.x) ** 2 + (state.tempPolygonPos.y - lastV.y) ** 2);
            if (distToLast < 5 / state.zoomLevel) {
                ctx.strokeStyle = '#f44336';
                ctx.lineWidth = 3 / state.zoomLevel;
                ctx.beginPath();
                ctx.arc(lastV.x, lastV.y, 10 / state.zoomLevel, 0, Math.PI * 2);
                ctx.stroke();
                
                ctx.fillStyle = '#f44336';
                ctx.font = `bold ${8 / state.zoomLevel}px sans-serif`;
                ctx.textAlign = 'center';
                ctx.fillText('å–æ¶ˆ', lastV.x, lastV.y - 15 / state.zoomLevel);
            }
        }
    }

        // å¯¸æ³•ç·šãƒ„ãƒ¼ãƒ«ä½¿ç”¨ä¸­ï¼šé¸æŠå¯èƒ½ãªç‚¹ã‚„è¾ºã‚’ãƒã‚¤ãƒ©ã‚¤ãƒˆ
    if (state.selectedTool === 'dimension') {
        // é¸æŠæ¸ˆã¿ã®å§‹ç‚¹ã‚’ãƒã‚¤ãƒ©ã‚¤ãƒˆ
        if (state.dimensionStart) {
            ctx.fillStyle = '#4caf50';
            ctx.strokeStyle = '#4caf50';
            ctx.lineWidth = 3 / state.zoomLevel;
            
            if (state.dimensionStart.type === 'vertex') {
                const room = state.rooms.find(r => r.id === state.dimensionStart.roomId);
                if (room) {
                    const v = room.vertices[state.dimensionStart.vertexIndex];
                    ctx.beginPath();
                    ctx.arc(v.x, v.y, 8 / state.zoomLevel, 0, Math.PI * 2);
                    ctx.fill();
                }
            } else if (state.dimensionStart.type === 'edge') {
                const room = state.rooms.find(r => r.id === state.dimensionStart.roomId);
                if (room) {
                    const v1 = room.vertices[state.dimensionStart.edgeIndex];
                    const v2 = room.vertices[(state.dimensionStart.edgeIndex + 1) % room.vertices.length];
                    ctx.beginPath();
                    ctx.moveTo(v1.x, v1.y);
                    ctx.lineTo(v2.x, v2.y);
                    ctx.stroke();
                }
            } else if (state.dimensionStart.type === 'wall-vertex') {
                const wall = state.walls.find(w => w.id === state.dimensionStart.wallId);
                if (wall) {
                    const px = state.dimensionStart.endpoint === 1 ? wall.x1 : wall.x2;
                    const py = state.dimensionStart.endpoint === 1 ? wall.y1 : wall.y2;
                    ctx.beginPath();
                    ctx.arc(px, py, 8 / state.zoomLevel, 0, Math.PI * 2);
                    ctx.fill();
                }
            } else if (state.dimensionStart.type === 'wall-midpoint') {
                const wall = state.walls.find(w => w.id === state.dimensionStart.wallId);
                if (wall) {
                    ctx.beginPath();
                    ctx.moveTo(wall.x1, wall.y1);
                    ctx.lineTo(wall.x2, wall.y2);
                    ctx.stroke();
                }
            }
        }
    }

    ctx.restore();
    updateUI();
}

function updateUI() {
    const ta = getTotalArea();
    document.getElementById('totalArea').textContent = ta;
    document.getElementById('totalAreaTop').textContent = ta;
    document.getElementById('roomCount').textContent = state.rooms.length;
    document.getElementById('scaleDisplay').textContent = Math.round(state.zoomLevel * 100);

    // è¤‡æ•°é¸æŠã‚¯ã‚¤ãƒƒã‚¯ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã®è¡¨ç¤º/éè¡¨ç¤º
    const multiQuickActions = document.getElementById('multiSelectQuickActions');
    if (state.selectedTool === 'multi-select' && state.multiSelectedRooms.length > 0) {
        multiQuickActions.style.display = 'block';
        document.getElementById('selectedCountQuick').textContent = state.multiSelectedRooms.length;
    } else {
        multiQuickActions.style.display = 'none';
    }

    // é¸æŠãƒ‘ãƒãƒ«ã®HTMLå†ç”Ÿæˆã‚’é¿ã‘ã‚‹ãŸã‚ã€é¸æŠã‚¢ã‚¤ãƒ†ãƒ ã®IDã‚’ãƒã‚§ãƒƒã‚¯
    const currentSelectedId = document.getElementById('selectedPanel').dataset.selectedId;
    const newSelectedId = state.selectedItem ? state.selectedItem.id : null;

    if (state.selectedItem && currentSelectedId !== String(newSelectedId)) {
        document.getElementById('selectedPanel').style.display = 'block';
        document.getElementById('selectedPanel').dataset.selectedId = newSelectedId;
        const tt = { room: 'éƒ¨å±‹', wall: 'å£', door: 'ãƒ‰ã‚¢', window: 'çª“', manikin: 'äººå‹', dimension: 'å¯¸æ³•ç·š' };
        document.getElementById('selectedType').innerHTML = '<strong>' + tt[state.selectedItem.type] + '</strong>';

        let c = '';
        if (state.selectedItem.type === 'room') {
            const dimCount = countRoomDimensions(state.selectedItem.id);
            c = `<label>éƒ¨å±‹å</label><input type="text" id="roomName" value="${state.selectedItem.name || ''}" placeholder="ä¾‹: ãƒªãƒ“ãƒ³ã‚°">
        <label>ç”¨é€”</label><input type="text" id="roomPurpose" value="${state.selectedItem.purpose || ''}" placeholder="ä¾‹: å±…é–“">
        <label>è‰²</label><input type="color" id="roomColor" class="color-picker" value="${state.selectedItem.color || '#e3f2fd'}">
        <button class="info-btn" id="toggleRoomDimensions" style="margin-top:10px;">ğŸ“ å¯¸æ³• (${dimCount})</button>`;
        } else if (state.selectedItem.type === 'door') {
            c = `<label>ãƒ‰ã‚¢å¹… (cm)</label><input type="number" id="itemWidth" value="${Math.round(state.selectedItem.width / state.scale * 100)}" min="60" max="120" step="5">`;
            
            if (state.selectedItem.doorType === 'swing') {
                c += `
                    <div class="btn-group" style="margin-top:10px;">
                        <button class="info-btn" id="flipDoorBtn">ğŸ”„ ä¸Šä¸‹</button>
                        <button class="info-btn" id="flipDoorHorizontalBtn">â†”ï¸ å·¦å³</button>
                    </div>
                `;
            }
            
            c += `<div class="hint" style="margin-top:8px;">ğŸ’¡ ãƒ‰ãƒ©ãƒƒã‚°ã—ã¦è¾ºã«æ²¿ã£ã¦ç§»å‹•ã§ãã¾ã™</div>`;
        }else if (state.selectedItem.type === 'window') {
            c = `<label>çª“å¹… (cm)</label><input type="number" id="itemWidth" value="${Math.round(state.selectedItem.width / state.scale * 100)}" min="60" max="200" step="10">`;
        } else if (state.selectedItem.type === 'wall') {
            const len = Math.sqrt((state.selectedItem.x2 - state.selectedItem.x1) ** 2 + (state.selectedItem.y2 - state.selectedItem.y1) ** 2);
            c = `<label>å£ã®é•·ã• (cm)</label><input type="number" id="wallLength" value="${Math.round(len / state.scale * 100)}" min="10" max="1000" step="5">
<label>å£ã®åšã• (cm)</label><input type="number" id="wallThicknessItem" value="${state.selectedItem.thickness}" min="5" max="50" step="5">`;
        } else if (state.selectedItem.type === 'dimension') {
            c = `<label>ã‚ªãƒ•ã‚»ãƒƒãƒˆè·é›¢</label><input type="number" id="dimOffset" value="${state.selectedItem.offset || 30}" min="-200" max="200" step="5">`;
        }
        document.getElementById('selectedControls').innerHTML = c;

        setTimeout(() => {
            const rn = document.getElementById('roomName');
            if (rn) {
                rn.addEventListener('input', e => { 
                    state.selectedItem.name = e.target.value;
                    requestAnimationFrame(() => draw());
                });
                rn.addEventListener('focus', e => e.target.select());
            }
            const rp = document.getElementById('roomPurpose');
            if (rp) {
                rp.addEventListener('input', e => { 
                    state.selectedItem.purpose = e.target.value;
                    requestAnimationFrame(() => draw());
                });
                rp.addEventListener('focus', e => e.target.select());
            }
            const rc = document.getElementById('roomColor');
            if (rc) rc.addEventListener('input', e => { 
                state.selectedItem.color = e.target.value;
                const room = state.rooms.find(r => r.id === state.selectedItem.id);
                if (room) room.color = e.target.value;
                draw(); 
            });
            const iw = document.getElementById('itemWidth');
            if (iw) iw.addEventListener('input', e => { state.selectedItem.width = e.target.value * state.scale / 100; draw(); });
            const wl = document.getElementById('wallLength');
            if (wl) wl.addEventListener('input', e => {
                const nl = e.target.value * state.scale / 100;
                const cl = Math.sqrt((state.selectedItem.x2 - state.selectedItem.x1) ** 2 + (state.selectedItem.y2 - state.selectedItem.y1) ** 2);
                if (cl > 0) {
                    const r = nl / cl;
                    const dx = state.selectedItem.x2 - state.selectedItem.x1, dy = state.selectedItem.y2 - state.selectedItem.y1;
                    state.selectedItem.x2 = state.selectedItem.x1 + dx * r;
                    state.selectedItem.y2 = state.selectedItem.y1 + dy * r;
                    draw();
                }
            });
            const wt = document.getElementById('wallThicknessItem');
            if (wt) wt.addEventListener('input', e => { state.selectedItem.thickness = parseInt(e.target.value); draw(); });
            const dimOffset = document.getElementById('dimOffset');
            if (dimOffset) dimOffset.addEventListener('input', e => { 
                state.selectedItem.offset = parseFloat(e.target.value);
                draw();
            });
            
            const toggleDimBtn = document.getElementById('toggleRoomDimensions');
            if (toggleDimBtn) toggleDimBtn.addEventListener('click', () => {
                toggleRoomDimensions(state.selectedItem.id);
            });
        const flipDoorBtn = document.getElementById('flipDoorBtn');
        if (flipDoorBtn) flipDoorBtn.addEventListener('click', () => {
            // ä¸Šä¸‹åè»¢
            state.selectedItem.flipped = !state.selectedItem.flipped;
            
            // é…åˆ—å†…ã®ãƒ‰ã‚¢ã‚‚æ›´æ–°
            const doorIndex = state.doors.findIndex(d => d.id === state.selectedItem.id);
            if (doorIndex !== -1) {
                state.doors[doorIndex].flipped = state.selectedItem.flipped;
            }
            
            saveHistory();
            draw();
        });

        const flipDoorHorizontalBtn = document.getElementById('flipDoorHorizontalBtn');
        if (flipDoorHorizontalBtn) flipDoorHorizontalBtn.addEventListener('click', () => {
            // å·¦å³åè»¢
            state.selectedItem.flippedHorizontal = !state.selectedItem.flippedHorizontal;
            
            // é…åˆ—å†…ã®ãƒ‰ã‚¢ã‚‚æ›´æ–°
            const doorIndex = state.doors.findIndex(d => d.id === state.selectedItem.id);
            if (doorIndex !== -1) {
                state.doors[doorIndex].flippedHorizontal = state.selectedItem.flippedHorizontal;
            }
            
            saveHistory();
            draw();
        });
        }, 0);
    } else if (!state.selectedItem) {
        document.getElementById('selectedPanel').style.display = 'none';
        document.getElementById('selectedPanel').dataset.selectedId = '';
    }
}

function findItemAt(x, y) {
    if (state.selectedTool === 'edit-vertex') {
        for (let r of state.rooms) {
            for (let i = 0; i < r.vertices.length; i++) {
                const v = r.vertices[i];
                if (Math.abs(x - v.x) < 10 / state.zoomLevel && Math.abs(y - v.y) < 10 / state.zoomLevel)
                    return { type: 'vertex', roomId: r.id, index: i, room: r };
            }
        }
    }

    if (state.selectedTool === 'add-vertex') {
        for (let r of state.rooms) {
            for (let i = 0; i < r.vertices.length; i++) {
                const j = (i + 1) % r.vertices.length;
                if (distanceToSegment(x, y, r.vertices[i].x, r.vertices[i].y, r.vertices[j].x, r.vertices[j].y) < 20 / state.zoomLevel)
                    return { type: 'edge-add', roomId: r.id, edgeIndex: i, room: r };
            }
        }
    }

    if (state.selectedTool === 'edit-edge') {
        for (let r of state.rooms) {
            for (let i = 0; i < r.vertices.length; i++) {
                const j = (i + 1) % r.vertices.length;
                const m = getEdgeMidpoint(r.vertices[i], r.vertices[j]);
                if (Math.abs(x - m.x) < 15 / state.zoomLevel && Math.abs(y - m.y) < 15 / state.zoomLevel)
                    return { type: 'edge-move', roomId: r.id, edgeIndex: i, room: r };
                if (distanceToSegment(x, y, r.vertices[i].x, r.vertices[i].y, r.vertices[j].x, r.vertices[j].y) < 20 / state.zoomLevel)
                    return { type: 'edge-move', roomId: r.id, edgeIndex: i, room: r };
            }
        }
    }

if (state.selectedTool === 'select') {
    // é¸æŠä¸­ã®éƒ¨å±‹ã®é ‚ç‚¹ã®ã¿ãƒªã‚µã‚¤ã‚ºå¯èƒ½ã«ã™ã‚‹
    if (state.selectedItem && state.selectedItem.type === 'room') {
        const r = state.rooms.find(rm => rm.id === state.selectedItem.id);
        if (r) {
            for (let i = 0; i < r.vertices.length; i++) {
                const v = r.vertices[i];
                if (Math.abs(x - v.x) < 10 / state.zoomLevel && Math.abs(y - v.y) < 10 / state.zoomLevel)
                    return { type: 'vertex-resize', roomId: r.id, index: i, room: r };
            }
        }
    }
    
    for (let w of state.walls) {
        if (Math.abs(x - w.x1) < 10 / state.zoomLevel && Math.abs(y - w.y1) < 10 / state.zoomLevel)
            return { type: 'wall-endpoint', wall: w, endpoint: 1 };
        if (Math.abs(x - w.x2) < 10 / state.zoomLevel && Math.abs(y - w.y2) < 10 / state.zoomLevel)
            return { type: 'wall-endpoint', wall: w, endpoint: 2 };
        const mx = (w.x1 + w.x2) / 2, my = (w.y1 + w.y2) / 2;
        if (Math.abs(x - mx) < 10 / state.zoomLevel && Math.abs(y - my) < 10 / state.zoomLevel)
            return { type: 'wall-rotate', wall: w };
    }
}

    for (let w of [...state.walls].reverse()) {
        if (distanceToSegment(x, y, w.x1, w.y1, w.x2, w.y2) < (w.thickness / 2 + 5) / state.zoomLevel)
            return { type: 'wall', ...w };
    }
    for (let r of [...state.rooms].reverse()) {
        if (isPointInPolygon({x, y}, r.vertices)) return { type: 'room', ...r };
    }
    for (let d of [...state.doors].reverse()) {
        const room = state.rooms.find(r => r.id === d.roomId);
        if (room) {
            const v1 = room.vertices[d.edgeIndex];
            const v2 = room.vertices[(d.edgeIndex + 1) % room.vertices.length];
            const dx = v2.x - v1.x;
            const dy = v2.y - v1.y;
            const px = v1.x + d.t * dx;
            const py = v1.y + d.t * dy;
            
            // ãƒ‰ã‚¢ã®å¹…ã‚‚è€ƒæ…®ã—ãŸåˆ¤å®š
            const angle = Math.atan2(dy, dx);
            const doorCenterX = px + Math.cos(angle) * d.width / 2;
            const doorCenterY = py + Math.sin(angle) * d.width / 2;
            
            if (Math.abs(x - doorCenterX) < (d.width / 2 + 10) / state.zoomLevel && 
                Math.abs(y - doorCenterY) < 20 / state.zoomLevel)
                return { type: 'door', ...d };
        }
    }
    for (let w of [...state.windows].reverse()) {
        const room = state.rooms.find(r => r.id === w.roomId);
        if (room) {
            const v1 = room.vertices[w.edgeIndex];
            const v2 = room.vertices[(w.edgeIndex + 1) % room.vertices.length];
            const dx = v2.x - v1.x;
            const dy = v2.y - v1.y;
            const px = v1.x + w.t * dx;
            const py = v1.y + w.t * dy;
            
            // çª“ã®å¹…ã‚‚è€ƒæ…®ã—ãŸåˆ¤å®š
            const angle = Math.atan2(dy, dx);
            const windowCenterX = px + Math.cos(angle) * w.width / 2;
            const windowCenterY = py + Math.sin(angle) * w.width / 2;
            
            if (Math.abs(x - windowCenterX) < (w.width / 2 + 10) / state.zoomLevel && 
                Math.abs(y - windowCenterY) < 20 / state.zoomLevel)
                return { type: 'window', ...w };
        }
    }

    //findItemAté–¢æ•°ã«å¯¸æ³•ç·šã®åˆ¤å®šã‚’è¿½åŠ 
    for (let m of [...state.manikins].reverse()) {
        if (Math.abs(x - m.x) < 30 / state.zoomLevel && Math.abs(y - m.y) < 30 / state.zoomLevel)
            return { type: 'manikin', ...m };
    }
    for (let dim of [...state.dimensions].reverse()) {
        const coords = getDimensionCoords(dim);
        if (coords) {
            const { p1, p2 } = coords;
            
            // è¾ºã®æ–¹å‘ã‚’å–å¾—ã™ã‚‹é–¢æ•°
            const getEdgeDirection = (ref) => {
                if (ref.type === 'edge') {
                    const room = state.rooms.find(r => r.id === ref.roomId);
                    if (room) {
                        const v1 = room.vertices[ref.edgeIndex];
                        const v2 = room.vertices[(ref.edgeIndex + 1) % room.vertices.length];
                        const dx = v2.x - v1.x;
                        const dy = v2.y - v1.y;
                        const len = Math.sqrt(dx * dx + dy * dy);
                        return { dx: dx / len, dy: dy / len };
                    }
                }
                return null;
            };
            
            const startEdge = getEdgeDirection(dim.start);
            const endEdge = getEdgeDirection(dim.end);
            
            let ox1, oy1, ox2, oy2;
            const offsetDist = dim.offset || 30;
            
            if (startEdge || endEdge) {
                const refEdge = startEdge || endEdge;
                const edgeDx = refEdge.dx;
                const edgeDy = refEdge.dy;
                const isHorizontal = Math.abs(edgeDx) > Math.abs(edgeDy);
                
            if (isHorizontal) {
                ox1 = p1.x + offsetDist;
                oy1 = p1.y;
                ox2 = p1.x + offsetDist;
                oy2 = p2.y;
            } else {
                ox1 = p1.x;
                oy1 = p1.y + offsetDist;
                ox2 = p2.x;
                oy2 = p1.y + offsetDist;
            }
            } else {
                const dx = p2.x - p1.x;
                const dy = p2.y - p1.y;
                const length = Math.sqrt(dx * dx + dy * dy);
                if (length < 0.1) continue;
                const nx = -dy / length;
                const ny = dx / length;
                ox1 = p1.x + nx * offsetDist;
                oy1 = p1.y + ny * offsetDist;
                ox2 = p2.x + nx * offsetDist;
                oy2 = p2.y + ny * offsetDist;
            }
            
            if (distanceToSegment(x, y, ox1, oy1, ox2, oy2) < 10 / state.zoomLevel)
                return { type: 'dimension', ...dim };
        }
    }
    return null;
}

// Ctrl+ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ã§ã®ãƒ–ãƒ©ã‚¦ã‚¶ã‚ºãƒ¼ãƒ ã‚’ç„¡åŠ¹åŒ–
canvas.addEventListener('wheel', e => {
    if (e.ctrlKey) {
        e.preventDefault();
    }
}, { passive: false });

canvas.addEventListener('mousedown', e => {
    // å¤šè§’å½¢ä½œæˆä¸­ã®å³ã‚¯ãƒªãƒƒã‚¯ã§æœ€å¾Œã®ç‚¹ã‚’å‰Šé™¤
    if (state.selectedTool === 'polygon' && state.polygonVertices.length > 0 && e.button === 2) {
        e.preventDefault();
        state.polygonVertices.pop();
        if (state.polygonVertices.length === 0) {
            state.tempPolygonPos = null;
        }
        draw();
        return;
    }
    
    // ãƒ‘ãƒ³ãƒ„ãƒ¼ãƒ«é¸æŠæ™‚ã¯å¸¸ã«ãƒ‘ãƒ³æ“ä½œ
    if (state.selectedTool === 'pan') {
        state.isPanning = true;
        state.dragStart = { x: e.clientX, y: e.clientY };
        canvas.style.cursor = 'grabbing';
        return;
    }
    
    console.log('mousedown:', state.selectedTool, 'isPanning:', state.isPanning, 'zoomLevel:', state.zoomLevel);
    const rect = canvas.getBoundingClientRect();
    const x = ((e.clientX - rect.left) - state.panOffset.x) / state.zoomLevel;
    const y = ((e.clientY - rect.top) - state.panOffset.y) / state.zoomLevel;

// è¤‡æ•°é¸æŠãƒ¢ãƒ¼ãƒ‰
if (state.selectedTool === 'multi-select') {
    const f = findItemAt(x, y);
    if (f && f.type === 'room') {
        const idx = state.multiSelectedRooms.indexOf(f.id);
        if (idx >= 0) {
            // æ—¢ã«é¸æŠã•ã‚Œã¦ã„ã‚‹å ´åˆã¯è§£é™¤
            state.multiSelectedRooms.splice(idx, 1);
        } else {
            // é¸æŠã•ã‚Œã¦ã„ãªã„å ´åˆã¯è¿½åŠ 
            state.multiSelectedRooms.push(f.id);
        }
        draw();
    }
    return;
}
    
    // å³ã‚¯ãƒªãƒƒã‚¯ã¾ãŸã¯Ctrl+ã‚¯ãƒªãƒƒã‚¯ã§ãƒ‘ãƒ³é–‹å§‹
    if (e.button === 2 || e.ctrlKey) {
        e.preventDefault();
        state.isPanning = true;
        state.dragStart = { x: e.clientX, y: e.clientY };
        canvas.style.cursor = 'grabbing';
        return;
    }
    
    const f = findItemAt(x, y);

    // å‰Šé™¤ãƒ„ãƒ¼ãƒ«ã®å‡¦ç†
    if (state.selectedTool === 'delete' && f) {
        if (f.type === 'room') {
            state.rooms = state.rooms.filter(r => r.id !== f.id);
            // éƒ¨å±‹ã«é–¢é€£ã™ã‚‹å¯¸æ³•ç·šã‚‚å‰Šé™¤
            state.dimensions = state.dimensions.filter(dim => dim.roomId !== f.id);
        }
        else if (f.type === 'wall') state.walls = state.walls.filter(w => w.id !== f.id);
        else if (f.type === 'door') state.doors = state.doors.filter(d => d.id !== f.id);
        else if (f.type === 'window') state.windows = state.windows.filter(w => w.id !== f.id);
        else if (f.type === 'manikin') state.manikins = state.manikins.filter(m => m.id !== f.id);
        else if (f.type === 'dimension') state.dimensions = state.dimensions.filter(d => d.id !== f.id);
        saveHistory();
        draw();
        return;
    }

    if (state.selectedTool === 'wall') {
        const v = findNearestVertex(x, y, 15);
        const snapPoint = v || snapPointToGrid({ x, y }); // é ‚ç‚¹ãŒãªã‘ã‚Œã°ã‚°ãƒªãƒƒãƒ‰ã‚¹ãƒŠãƒƒãƒ—
        
        if (!state.wallStartVertex) {
            state.wallStartVertex = snapPoint;
            draw();
        } else {
            state.walls.push({
                id: Date.now(), type: 'wall',
                x1: state.wallStartVertex.x, y1: state.wallStartVertex.y,
                x2: snapPoint.x, y2: snapPoint.y, thickness: state.wallThickness
            });
            state.wallStartVertex = null;
            state.tempWallEndPos = null;
            saveHistory();
            draw();
        }
        return;
    }

    //mousedownã‚¤ãƒ™ãƒ³ãƒˆã«å¯¸æ³•ç·šä½œæˆå‡¦ç†ã‚’è¿½åŠ 
    if (state.selectedTool === 'dimension') {
        const getDimensionReference = (x, y) => {
            for (let r of state.rooms) {
                for (let i = 0; i < r.vertices.length; i++) {
                    const v = r.vertices[i];
                    if (Math.abs(x - v.x) < 10 / state.zoomLevel && Math.abs(y - v.y) < 10 / state.zoomLevel) {
                        return { type: 'vertex', roomId: r.id, vertexIndex: i, x: v.x, y: v.y };
                    }
                }
            }
            
            // è¾ºå…¨ä½“ã‚’åˆ¤å®šï¼ˆä¸­ç‚¹ä»¥å¤–ã§ã‚‚OKï¼‰
            for (let r of state.rooms) {
                for (let i = 0; i < r.vertices.length; i++) {
                    const j = (i + 1) % r.vertices.length;
                    const v1 = r.vertices[i];
                    const v2 = r.vertices[j];
                    const dist = distanceToSegment(x, y, v1.x, v1.y, v2.x, v2.y);
                    if (dist < 15 / state.zoomLevel) {
                        // ã‚¯ãƒªãƒƒã‚¯ä½ç½®ã‚’è¾ºä¸Šã«æŠ•å½±
                        const dx = v2.x - v1.x;
                        const dy = v2.y - v1.y;
                        const l2 = dx * dx + dy * dy;
                        let t = ((x - v1.x) * dx + (y - v1.y) * dy) / l2;
                        t = Math.max(0, Math.min(1, t));
                        const px = v1.x + t * dx;
                        const py = v1.y + t * dy;
                        return { type: 'edge', roomId: r.id, edgeIndex: i, x: px, y: py };
                    }
                }
            }
            
            for (let w of state.walls) {
                if (Math.abs(x - w.x1) < 10 / state.zoomLevel && Math.abs(y - w.y1) < 10 / state.zoomLevel) {
                    return { type: 'wall-vertex', wallId: w.id, endpoint: 1, x: w.x1, y: w.y1 };
                }
                if (Math.abs(x - w.x2) < 10 / state.zoomLevel && Math.abs(y - w.y2) < 10 / state.zoomLevel) {
                    return { type: 'wall-vertex', wallId: w.id, endpoint: 2, x: w.x2, y: w.y2 };
                }
                const mx = (w.x1 + w.x2) / 2;
                const my = (w.y1 + w.y2) / 2;
                if (Math.abs(x - mx) < 12 / state.zoomLevel && Math.abs(y - my) < 12 / state.zoomLevel) {
                    return { type: 'wall-midpoint', wallId: w.id, x: mx, y: my };
                }
            }
            
            return null;  // ç©ºç™½ã®ç‚¹ã¯é¸æŠä¸å¯
        };
        
        const ref = getDimensionReference(x, y);
        
        if (!state.dimensionStart) {
            state.dimensionStart = ref;
            draw();
        } else {
            // ãƒã‚¦ã‚¹ä½ç½®ã‹ã‚‰è‡ªå‹•çš„ã«ã‚ªãƒ•ã‚»ãƒƒãƒˆæ–¹å‘ã‚’è¨ˆç®—
let autoOffset = 30;
if (state.tempDimensionEnd) {
    const startEdge = state.dimensionStart.type === 'edge' || state.dimensionStart.type === 'wall-midpoint';
    const endEdge = ref.type === 'edge' || ref.type === 'wall-midpoint';
    
    // è¾ºãŒå«ã¾ã‚Œã‚‹å ´åˆ
    if (startEdge && endEdge) {
        // 2ã¤ã®è¾ºã®è·é›¢ã®æ–¹å‘ã‚’åˆ¤å®š
        const p1 = state.dimensionStart;
        const p2 = ref;
        const dx = p2.x - p1.x;
        const dy = p2.y - p1.y;
        
        // è¾ºã®æ–¹å‘ã‚’å–å¾—
        let edgeDx = 0, edgeDy = 0;
        if (state.dimensionStart.type === 'edge') {
            const room = state.rooms.find(r => r.id === state.dimensionStart.roomId);
            const v1 = room.vertices[state.dimensionStart.edgeIndex];
            const v2 = room.vertices[(state.dimensionStart.edgeIndex + 1) % room.vertices.length];
            edgeDx = v2.x - v1.x;
            edgeDy = v2.y - v1.y;
        }
        
        const isHorizontal = Math.abs(edgeDx) > Math.abs(edgeDy);
        if (isHorizontal) {
            autoOffset = dx >= 0 ? 30 : -30;
        } else {
            autoOffset = dy >= 0 ? 30 : -30;
        }
    } else if (startEdge || endEdge) {
        // è¾ºã®æ³•ç·šæ–¹å‘ã‚’è¨ˆç®—
        let nx = 0, ny = 0;
        
        if (state.dimensionStart.type === 'edge') {
            const room = state.rooms.find(r => r.id === state.dimensionStart.roomId);
            const v1 = room.vertices[state.dimensionStart.edgeIndex];
            const v2 = room.vertices[(state.dimensionStart.edgeIndex + 1) % room.vertices.length];
            const dx = v2.x - v1.x;
            const dy = v2.y - v1.y;
            const len = Math.sqrt(dx * dx + dy * dy);
            nx = -dy / len;
            ny = dx / len;

            } else if (state.dimensionStart.type === 'wall-midpoint') {
                const wall = state.walls.find(w => w.id === state.dimensionStart.wallId);
                const dx = wall.x2 - wall.x1;
                const dy = wall.y2 - wall.y1;
                const len = Math.sqrt(dx * dx + dy * dy);
                nx = -dy / len;
                ny = dx / len;
            } else if (ref.type === 'edge') {
                const room = state.rooms.find(r => r.id === ref.roomId);
                const v1 = room.vertices[ref.edgeIndex];
                const v2 = room.vertices[(ref.edgeIndex + 1) % room.vertices.length];
                const dx = v2.x - v1.x;
                const dy = v2.y - v1.y;
                const len = Math.sqrt(dx * dx + dy * dy);
                nx = -dy / len;
                ny = dx / len;
            } else if (ref.type === 'wall-midpoint') {
                const wall = state.walls.find(w => w.id === ref.wallId);
                const dx = wall.x2 - wall.x1;
                const dy = wall.y2 - wall.y1;
                const len = Math.sqrt(dx * dx + dy * dy);
                nx = -dy / len;
                ny = dx / len;
            }
                    
            // ãƒã‚¦ã‚¹ä½ç½®ã‹ã‚‰ã®æ–¹å‘
            const p1 = state.dimensionStart;
            const mx = state.tempDimensionEnd.x - p1.x;
            const my = state.tempDimensionEnd.y - p1.y;
            
            // æ³•ç·šæ–¹å‘ã¨ãƒã‚¦ã‚¹æ–¹å‘ã®å†…ç©ã§å‘ãã‚’åˆ¤å®š
            const dot = mx * nx + my * ny;
            autoOffset = dot > 0 ? 30 : -30;
            } else {
                // ç‚¹åŒå£«ã®å ´åˆã‚‚ãƒã‚¦ã‚¹æ–¹å‘ã«å¿œã˜ã¦ã‚ªãƒ•ã‚»ãƒƒãƒˆ
                const p1 = state.dimensionStart;
                const p2 = ref;
                const dx = p2.x - p1.x;
                const dy = p2.y - p1.y;
                const len = Math.sqrt(dx * dx + dy * dy);
                
                if (len > 0.1) {
                    const nx = -dy / len;
                    const ny = dx / len;
                    const mx = state.tempDimensionEnd.x - p1.x;
                    const my = state.tempDimensionEnd.y - p1.y;
                    const dot = mx * nx + my * ny;
                    autoOffset = dot > 0 ? 30 : -30;
                }
            }
        }
            
        // å¯¸æ³•ç·šãŒéƒ¨å±‹ã®é ‚ç‚¹/è¾ºã‚’å‚ç…§ã—ã¦ã„ã‚‹å ´åˆã€roomIdã‚’è¨˜éŒ²
        let dimensionRoomId = null;
        if (state.dimensionStart.type === 'vertex' || state.dimensionStart.type === 'edge') {
            dimensionRoomId = state.dimensionStart.roomId;
        } else if (ref.type === 'vertex' || ref.type === 'edge') {
            dimensionRoomId = ref.roomId;
        }
        
        state.dimensions.push({
            id: Date.now(),
            type: 'dimension',
            start: state.dimensionStart,
            end: ref,
            offset: autoOffset,
            roomId: dimensionRoomId
        });

        state.dimensionStart = null;
        state.tempDimensionEnd = null;
        saveHistory();
        draw();
        }
        return;
    }

    if (f && f.type === 'wall') {
        state.selectedItem = f;
        state.selectedTool = 'select';
        document.querySelectorAll('.tool-btn[data-tool]').forEach(b => b.classList.remove('active'));
        document.querySelector('.tool-btn[data-tool="select"]').classList.add('active');
        draw();
        return;
    }

    if (state.selectedTool === 'add-vertex' && f && f.type === 'edge-add') {
        const r = state.rooms.find(rm => rm.id === f.roomId);
        if (r) {
            r.vertices.splice(f.edgeIndex + 1, 0, snapPointToGrid({ x, y }));
            state.selectedItem = r;
            saveHistory();
            switchToSelectTool();
            draw();
        }
        return;
    }

    if (state.selectedTool === 'edit-edge' && f && f.type === 'edge-move') {
        state.selectedEdge = { roomId: f.roomId, index: f.edgeIndex };
        state.selectedItem = f.room;
        state.isDragging = true;
        state.dragStart = { x: snapToGrid(x), y: snapToGrid(y) };
        
        const r = state.rooms.find(rm => rm.id === f.roomId);
        const i = f.edgeIndex, j = (i + 1) % r.vertices.length;
        const ev = { x: r.vertices[j].x - r.vertices[i].x, y: r.vertices[j].y - r.vertices[i].y };
        const el = Math.sqrt(ev.x ** 2 + ev.y ** 2);
        state.edgeNormal = { x: -ev.y / el, y: ev.x / el };
        draw();
        return;
    }

    if (state.selectedTool === 'edit-vertex' && f && f.type === 'vertex') {
        state.selectedVertex = { roomId: f.roomId, index: f.index };
        state.selectedItem = f.room;
        state.isDragging = true;
        state.dragStart = { x, y };
        draw();
        return;
    }

if (state.selectedTool === 'select') {
        if (f && f.type === 'wall-endpoint') {
            state.selectedItem = f.wall;
            state.selectedVertex = { endpoint: f.endpoint };
            state.dragStart = { x, y };
            // isDraggingã¯mousemoveã§è¨­å®š
        } else if (f && f.type === 'wall-rotate') {
            state.selectedItem = f.wall;
            state.isRotating = false; // mousemoveã§è¨­å®š
            state.dragStart = { x, y };
        } else if (f && f.type === 'vertex-resize') {
            state.selectedVertex = { roomId: f.roomId, index: f.index };
            state.selectedItem = f.room;
            state.dragStart = { x, y };
            // isDraggingã¯mousemoveã§è¨­å®š
        } else if (f && (f.type === 'door' || f.type === 'window')) {
            // ãƒ‰ã‚¢ãƒ»çª“ã®é¸æŠæ™‚ - å°‚ç”¨ã®ç§»å‹•ãƒ¢ãƒ¼ãƒ‰ã‚’è¨­å®š
            console.log('ãƒ‰ã‚¢ãƒ»çª“ã‚’é¸æŠ:', f);  // ğŸ” è¿½åŠ 
            state.selectedItem = f;
            state.selectedVertex = null;
            state.selectedEdge = null;
            state.dragStart = { x, y };
            state.isDragging = false;  // mousemoveã§è¨­å®š
        }else if (f) {
            state.selectedItem = f;
            state.selectedVertex = null;
            state.selectedEdge = null;
            state.dragStart = { x, y };
            state.dragOffset = { x: x - (f.x || 0), y: y - (f.y || 0) };
            // isDraggingã¯mousemoveã§è¨­å®š
        } else {
            state.selectedItem = null;
            state.selectedVertex = null;
            state.selectedEdge = null;
        }
        draw();
        return;
    }

if (!f) {
        const sx = snapToGrid(x), sy = snapToGrid(y);
        if (state.selectedTool === 'room') {
            const newRoom = {
                id: Date.now(), type: 'room',
                vertices: [{ x: sx, y: sy }, { x: sx + 63, y: sy }, { x: sx + 63, y: sy + 63 }, { x: sx, y: sy + 63 }],
                name: 'éƒ¨å±‹' + (state.rooms.length + 1), purpose: '', color: '#e3f2fd'
            };
            state.rooms.push(newRoom);
            state.selectedItem = newRoom;
            saveHistory();
            switchToSelectTool();            
        } else if (state.selectedTool === 'polygon') {
            // å¤šè§’å½¢ä½œæˆãƒ¢ãƒ¼ãƒ‰
            // æ—¢å­˜ã®é ‚ç‚¹ã‚’å„ªå…ˆçš„ã«æ¤œç´¢
            const nearestVertex = findNearestVertex(x, y, 20);
            const pointToAdd = nearestVertex || snapPointToGrid({ x, y });
            
            // æœ€å¾Œã«è¿½åŠ ã—ãŸç‚¹ã¨åŒã˜å ´æ‰€ã‚’ã‚¯ãƒªãƒƒã‚¯ã—ãŸå ´åˆã¯ã‚­ãƒ£ãƒ³ã‚»ãƒ«
            if (state.polygonVertices.length > 0) {
                const lastV = state.polygonVertices[state.polygonVertices.length - 1];
                const distToLast = Math.sqrt((pointToAdd.x - lastV.x) ** 2 + (pointToAdd.y - lastV.y) ** 2);
                if (distToLast < 5 / state.zoomLevel) {
                    // åŒã˜ç‚¹ã‚’ã‚¯ãƒªãƒƒã‚¯ = æœ€å¾Œã®ç‚¹ã‚’å‰Šé™¤
                    state.polygonVertices.pop();
                    if (state.polygonVertices.length === 0) {
                        state.tempPolygonPos = null;
                    }
                    draw();
                    return;
                }
            }
            
            if (state.polygonVertices.length >= 3) {
                const firstV = state.polygonVertices[0];
                const dist = Math.sqrt((pointToAdd.x - firstV.x) ** 2 + (pointToAdd.y - firstV.y) ** 2);
                
                // æœ€åˆã®é ‚ç‚¹ã«è¿‘ã„å ´åˆã€ã¾ãŸã¯å¤šè§’å½¢ã®å†…éƒ¨ã‚’ã‚¯ãƒªãƒƒã‚¯ã—ãŸå ´åˆã¯å®Œäº†
                const isNearFirst = dist < 15 / state.zoomLevel;
                const isInsidePolygon = state.polygonVertices.length >= 3 && 
                                       isPointInPolygon(pointToAdd, state.polygonVertices);
                
                if (isNearFirst || isInsidePolygon) {
                    // å®Œäº†å‡¦ç†
                    let finalVertices = [...state.polygonVertices];
                    
                    // 3ç‚¹ã®å ´åˆã¯é•·æ–¹å½¢ã«å¤‰æ›
                    if (finalVertices.length === 3) {
                        finalVertices = convertTriangleToRectangle(finalVertices);
                    } else if (finalVertices.length >= 4) {
                        // 4ç‚¹ä»¥ä¸Šã®å ´åˆã¯å‡¸åŒ…ã‚’è¨ˆç®—ã—ã¦æ•´åˆ—
                        finalVertices = convexHull([...finalVertices]);
                    }
                    
                    const newRoom = {
                        id: Date.now(), type: 'room',
                        vertices: finalVertices,
                        name: 'éƒ¨å±‹' + (state.rooms.length + 1), purpose: '', color: '#e3f2fd'
                    };
                    state.rooms.push(newRoom);
                    state.selectedItem = newRoom;
                    state.polygonVertices = [];
                    state.tempPolygonPos = null;
                    saveHistory();
                    switchToSelectTool();
                    return;
                }
            }
            // æ–°ã—ã„é ‚ç‚¹ã‚’è¿½åŠ 
            state.polygonVertices.push(pointToAdd);
            draw();
            } else if (state.selectedTool === 'door-swing' || state.selectedTool === 'door-sliding') {
                const edge = findNearestEdge(x, y, 50);
                if (edge) {
                    const doorWidth = 80 * state.scale / 100;
                    const room = state.rooms.find(r => r.id === edge.roomId);
                    const v1 = room.vertices[edge.edgeIndex];
                    const v2 = room.vertices[(edge.edgeIndex + 1) % room.vertices.length];
                    const edgeLength = Math.sqrt((v2.x - v1.x) ** 2 + (v2.y - v1.y) ** 2);
                    
                    // è¾ºã®é•·ã•ãŒãƒ‰ã‚¢å¹…ã‚ˆã‚ŠçŸ­ã„å ´åˆã¯é…ç½®ä¸å¯
                    if (edgeLength < doorWidth) {
                        alert('ã“ã®è¾ºã¯çŸ­ã™ãã¦ãƒ‰ã‚¢ã‚’é…ç½®ã§ãã¾ã›ã‚“');
                        return;
                    }
                    
                    // è¾ºã®ä¸­å¤®ã«é…ç½®ï¼ˆt=0.5ï¼‰
                    const centerT = 0.5;
                    
                    state.doors.push({ 
                        id: Date.now(), 
                        type: 'door', 
                        doorType: state.selectedTool === 'door-swing' ? 'swing' : 'sliding',
                        roomId: edge.roomId,
                        edgeIndex: edge.edgeIndex,
                        t: centerT,
                        width: doorWidth,
                        rotation: edge.angle,
                        flipped: false,           // ä¸Šä¸‹åè»¢
                        flippedHorizontal: false  // å·¦å³åè»¢
                    });
                    state.selectedItem = state.doors[state.doors.length - 1];
                    saveHistory();
                    switchToSelectTool();
                }
            } else if (state.selectedTool === 'window') {
                const edge = findNearestEdge(x, y, 50);
                if (edge) {
                    const windowWidth = 90 * state.scale / 100;
                    const room = state.rooms.find(r => r.id === edge.roomId);
                    const v1 = room.vertices[edge.edgeIndex];
                    const v2 = room.vertices[(edge.edgeIndex + 1) % room.vertices.length];
                    const edgeLength = Math.sqrt((v2.x - v1.x) ** 2 + (v2.y - v1.y) ** 2);
                    
                    // è¾ºã®é•·ã•ãŒçª“å¹…ã‚ˆã‚ŠçŸ­ã„å ´åˆã¯é…ç½®ä¸å¯
                    if (edgeLength < windowWidth) {
                        alert('ã“ã®è¾ºã¯çŸ­ã™ãã¦çª“ã‚’é…ç½®ã§ãã¾ã›ã‚“');
                        return;
                    }
                    
                    // è¾ºã®ä¸­å¤®ã«é…ç½®ï¼ˆt=0.5ï¼‰
                    const centerT = 0.5;
                    
                    state.windows.push({ 
                        id: Date.now(), 
                        type: 'window',
                        roomId: edge.roomId,
                        edgeIndex: edge.edgeIndex,
                        t: centerT,  // ä¸­å¤®ã«é…ç½®
                        width: windowWidth,
                        rotation: edge.angle
                    });
                    state.selectedItem = state.windows[state.windows.length - 1];
                    saveHistory();
                    switchToSelectTool();
                }
            } else if (state.selectedTool === 'manikin') {
            state.manikins.push({ id: Date.now(), type: 'manikin', x: sx, y: sy, rotation: 0 });
            saveHistory();
        }
        draw();
    } else if (state.selectedTool === 'select') {
        // ç©ºç™½éƒ¨åˆ†ã‚’ã‚¯ãƒªãƒƒã‚¯ã—ãŸå ´åˆã¯ãƒ‘ãƒ³é–‹å§‹
        state.isPanning = true;
        state.dragStart = { x: e.clientX, y: e.clientY };
    }
});

canvas.addEventListener('mousemove', e => {
    const rect = canvas.getBoundingClientRect();
    const x = ((e.clientX - rect.left) - state.panOffset.x) / state.zoomLevel;
    const y = ((e.clientY - rect.top) - state.panOffset.y) / state.zoomLevel;

    // ãƒ‰ãƒ©ãƒƒã‚°é–‹å§‹åˆ¤å®šï¼ˆ5pxä»¥ä¸Šå‹•ã„ãŸã‚‰ãƒ‰ãƒ©ãƒƒã‚°ã¨ã¿ãªã™ï¼‰
    if (!state.isDragging && state.dragStart && !state.isPanning) {
        const clientX = e.clientX;
        const clientY = e.clientY;
        const startClientX = (state.dragStart.x * state.zoomLevel) + state.panOffset.x + rect.left;
        const startClientY = (state.dragStart.y * state.zoomLevel) + state.panOffset.y + rect.top;
        const dx = Math.abs(clientX - startClientX);
        const dy = Math.abs(clientY - startClientY);
            if (dx > 5 || dy > 5) {
                state.isDragging = true;
                // ãƒ‰ã‚¢ãƒ»çª“ã®å ´åˆã¯å°‚ç”¨ãƒ•ãƒ©ã‚°ã‚’è¨­å®š
                if (state.selectedItem && (state.selectedItem.type === 'door' || state.selectedItem.type === 'window')) {
                    state.isDraggingDoorWindow = true;
                    console.log('ãƒ‰ã‚¢ãƒ»çª“ã®ãƒ‰ãƒ©ãƒƒã‚°é–‹å§‹ï¼', state.selectedItem);  // ğŸ” è¿½åŠ 
                }
                if (state.selectedItem && state.selectedItem.type === 'wall' && !state.selectedVertex) {
                    state.isRotating = true;
                }
            }
        }

        // ã‚«ãƒ¼ã‚½ãƒ«ã®æ›´æ–°
        if (!state.isDragging && !state.isPanning) {
            if (state.selectedTool === 'pan') {
                canvas.style.cursor = 'grab';
            } else {
                const item = findItemAt(x, y);
                if (item || state.selectedTool !== 'select') {
                    canvas.style.cursor = state.selectedTool === 'select' ? 'move' : 'crosshair';
                } else {
                    canvas.style.cursor = 'grab';
                }
            }
        }

        if (state.isPanning) {
        // ãƒ‘ãƒ³å‡¦ç†
        const dx = e.clientX - state.dragStart.x;
        const dy = e.clientY - state.dragStart.y;
        state.panOffset.x += dx;
        state.panOffset.y += dy;
        state.dragStart = { x: e.clientX, y: e.clientY };
        draw();
        return;
    }

    if (state.selectedTool === 'wall' && state.wallStartVertex) {
        const nv = findNearestVertex(x, y, 15);
        state.tempWallEndPos = nv || snapPointToGrid({ x, y });
        draw();
        return;
    }
    // mousemoveã‚¤ãƒ™ãƒ³ãƒˆã«å¯¸æ³•ç·šãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ã‚’è¿½åŠ 
    if (state.selectedTool === 'dimension' && state.dimensionStart) {
        state.tempDimensionEnd = { x, y };
        draw();
        return;
    }

    // å¤šè§’å½¢ä½œæˆä¸­ã®ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼
    if (state.selectedTool === 'polygon' && state.polygonVertices.length > 0) {
        // æ—¢å­˜ã®é ‚ç‚¹ã«ã‚¹ãƒŠãƒƒãƒ—
        const nearestVertex = findNearestVertex(x, y, 20);
        state.tempPolygonPos = nearestVertex || { x, y };
        draw();
        return;
    }

if (state.isDragging) {
    if (state.isDraggingDoorWindow && state.selectedItem && (state.selectedItem.type === 'door' || state.selectedItem.type === 'window')) {
        // ãƒ‰ã‚¢ãƒ»çª“ã¯åŒã˜è¾ºã«æ²¿ã£ã¦è‡ªç”±ã«ç§»å‹•
        const room = state.rooms.find(r => r.id === state.selectedItem.roomId);
        if (room && state.selectedItem.edgeIndex < room.vertices.length) {
            const v1 = room.vertices[state.selectedItem.edgeIndex];
            const v2 = room.vertices[(state.selectedItem.edgeIndex + 1) % room.vertices.length];
            
            // è¾ºã®ãƒ™ã‚¯ãƒˆãƒ«ã‚’è¨ˆç®—
            const dx = v2.x - v1.x;
            const dy = v2.y - v1.y;
            const edgeLength = Math.sqrt(dx * dx + dy * dy);
            
            if (edgeLength > 0) {
                // ãƒã‚¦ã‚¹ä½ç½®ã‹ã‚‰è¾ºä¸Šã¸ã®æŠ•å½±ç‚¹ã‚’è¨ˆç®—
                const l2 = dx * dx + dy * dy;
                let t = ((x - v1.x) * dx + (y - v1.y) * dy) / l2;
                
                // ãƒ‰ã‚¢ãƒ»çª“ã®å¹…ã‚’è€ƒæ…®ã—ã¦ã€è¾ºã‹ã‚‰ã¯ã¿å‡ºã•ãªã„ã‚ˆã†ã«åˆ¶é™
                const itemWidth = state.selectedItem.width;
                const minT = itemWidth / (2 * edgeLength);
                const maxT = 1 - itemWidth / (2 * edgeLength);
                
                // tã‚’åˆ¶é™ç¯„å›²å†…ã«ã‚¯ãƒ©ãƒ³ãƒ—
                t = Math.max(minT, Math.min(maxT, t));
                
                // é…åˆ—å†…ã®ã‚¢ã‚¤ãƒ†ãƒ ã‚’ç›´æ¥æ›´æ–°
                if (state.selectedItem.type === 'door') {
                    const doorIndex = state.doors.findIndex(d => d.id === state.selectedItem.id);
                    if (doorIndex !== -1) {
                        state.doors[doorIndex].t = t;
                        state.selectedItem.t = t;
                    }
                } else if (state.selectedItem.type === 'window') {
                    const windowIndex = state.windows.findIndex(w => w.id === state.selectedItem.id);
                    if (windowIndex !== -1) {
                        state.windows[windowIndex].t = t;
                        state.selectedItem.t = t;
                    }
                }
                draw();
            }
        }
    } else if (state.isRotating && state.selectedItem && state.selectedItem.type === 'wall') {
        const w = state.selectedItem;
        const cx = (w.x1 + w.x2) / 2, cy = (w.y1 + w.y2) / 2;
        const len = Math.sqrt((w.x2 - w.x1) ** 2 + (w.y2 - w.y1) ** 2);
        const ang = Math.atan2(y - cy, x - cx);
        w.x1 = cx - Math.cos(ang) * len / 2;
        w.y1 = cy - Math.sin(ang) * len / 2;
        w.x2 = cx + Math.cos(ang) * len / 2;
        w.y2 = cy + Math.sin(ang) * len / 2;
        draw();
    } 
     else if (state.selectedVertex && state.selectedVertex.endpoint) {
        const w = state.selectedItem;
        const nv = findNearestVertex(x, y, 15);
        const tp = nv || snapPointToGrid({ x, y });
        if (state.selectedVertex.endpoint === 1) {
            w.x1 = tp.x; w.y1 = tp.y;
        } else {
            w.x2 = tp.x; w.y2 = tp.y;
        }
        draw();
    } else if (state.selectedVertex && state.selectedVertex.roomId && state.selectedTool === 'select') {
        const r = state.rooms.find(rm => rm.id === state.selectedVertex.roomId);
        if (r && e.shiftKey && r.vertices.length === 4) {
            // ShiftæŠ¼ä¸‹æ™‚ã®å‡¦ç†...
            const idx = state.selectedVertex.index;
            const oppositeIdx = (idx + 2) % 4;
            const fixedPoint = r.vertices[oppositeIdx];
            const newPos = snapPointToGrid({ x, y });
            const dx = newPos.x - fixedPoint.x;
            const dy = newPos.y - fixedPoint.y;
            const size = Math.max(Math.abs(dx), Math.abs(dy));
            const minSize = 20;
            if (size < minSize) return;
            const signX = dx >= 0 ? 1 : -1;
            const signY = dy >= 0 ? 1 : -1;
            r.vertices[oppositeIdx] = fixedPoint;
            r.vertices[idx] = { x: fixedPoint.x + signX * size, y: fixedPoint.y + signY * size };
            r.vertices[(idx + 1) % 4] = { x: fixedPoint.x + signX * size, y: fixedPoint.y };
            r.vertices[(idx + 3) % 4] = { x: fixedPoint.x, y: fixedPoint.y + signY * size };
            state.selectedItem = r;
        } else if (r && r.vertices.length === 4) {
            // é€šå¸¸ã®ãƒªã‚µã‚¤ã‚ºå‡¦ç†...
            const idx = state.selectedVertex.index;
            const oppositeIdx = (idx + 2) % 4;
            const fixedPoint = r.vertices[oppositeIdx];
            const newPos = snapPointToGrid({ x, y });
            const dx = newPos.x - fixedPoint.x;
            const dy = newPos.y - fixedPoint.y;
            const minSize = 20;
            if (Math.abs(dx) < minSize || Math.abs(dy) < minSize) return;
            const newVertices = [
                { x: fixedPoint.x, y: fixedPoint.y },
                { x: fixedPoint.x + dx, y: fixedPoint.y },
                { x: fixedPoint.x + dx, y: fixedPoint.y + dy },
                { x: fixedPoint.x, y: fixedPoint.y + dy }
            ];
            const rotatedVertices = [];
            for (let i = 0; i < 4; i++) {
                rotatedVertices[i] = newVertices[(i + oppositeIdx) % 4];
            }
            r.vertices = rotatedVertices;
            state.selectedItem = r;
        } else if (r) {
            r.vertices[state.selectedVertex.index] = snapPointToGrid({ x, y });
            state.selectedItem = r;
        }
        draw();
    } else if (state.selectedVertex && state.selectedVertex.roomId) {
        const r = state.rooms.find(rm => rm.id === state.selectedVertex.roomId);
        if (r) {
            r.vertices[state.selectedVertex.index] = snapPointToGrid({ x, y });
            state.selectedItem = r;
        }
        draw();
    } else if (state.selectedEdge) {
        const r = state.rooms.find(rm => rm.id === state.selectedEdge.roomId);
        if (r && state.edgeNormal) {
            const dx = x - state.dragStart.x, dy = y - state.dragStart.y;
            const nd = dx * state.edgeNormal.x + dy * state.edgeNormal.y;
            const mx = nd * state.edgeNormal.x, my = nd * state.edgeNormal.y;
            const smx = snapToGrid(mx), smy = snapToGrid(my);
            
            if (smx !== 0 || smy !== 0) {
                const i = state.selectedEdge.index, j = (i + 1) % r.vertices.length;
                r.vertices[i] = { x: r.vertices[i].x + smx, y: r.vertices[i].y + smy };
                r.vertices[j] = { x: r.vertices[j].x + smx, y: r.vertices[j].y + smy };
                state.dragStart = { x: state.dragStart.x + smx, y: state.dragStart.y + smy };
                state.selectedItem = r;
                draw();
            }
        }
    } else if (state.selectedItem && state.selectedItem.type === 'room' && state.selectedTool === 'select') {
        const dx = x - state.dragStart.x, dy = y - state.dragStart.y;
        const r = state.rooms.find(rm => rm.id === state.selectedItem.id);
        if (r) {
            r.vertices = r.vertices.map(v => ({ x: v.x + dx, y: v.y + dy }));
            state.selectedItem = r;
        }
        state.dragStart = { x, y };
        draw();
    } else if (state.selectedItem && state.selectedItem.type === 'wall' && state.selectedTool === 'select') {
        const dx = x - state.dragStart.x, dy = y - state.dragStart.y;
        state.selectedItem.x1 += dx; state.selectedItem.y1 += dy;
        state.selectedItem.x2 += dx; state.selectedItem.y2 += dy;
        state.dragStart = { x, y };
        draw();
    } else if (state.selectedItem && state.selectedItem.type === 'dimension') {
        const dx = x - state.dragStart.x;
        const dy = y - state.dragStart.y;
        const coords = getDimensionCoords(state.selectedItem);
        if (coords) {
            const { p1, p2 } = coords;
            const getEdgeDirection = (ref) => {
                if (ref.type === 'edge') {
                    const room = state.rooms.find(r => r.id === ref.roomId);
                    if (room) {
                        const v1 = room.vertices[ref.edgeIndex];
                        const v2 = room.vertices[(ref.edgeIndex + 1) % room.vertices.length];
                        const dx = v2.x - v1.x;
                        const dy = v2.y - v1.y;
                        const len = Math.sqrt(dx * dx + dy * dy);
                        return { dx: dx / len, dy: dy / len };
                    }
                }
                return null;
            };
            const startEdge = getEdgeDirection(state.selectedItem.start);
            const endEdge = getEdgeDirection(state.selectedItem.end);
            if (startEdge || endEdge) {
                const refEdge = startEdge || endEdge;
                const isHorizontal = Math.abs(refEdge.dx) > Math.abs(refEdge.dy);
                if (isHorizontal) {
                    state.selectedItem.offset = (state.selectedItem.offset || 30) + dx;
                } else {
                    state.selectedItem.offset = (state.selectedItem.offset || 30) + dy;
                }
            } else {
                const vecX = p2.x - p1.x;
                const vecY = p2.y - p1.y;
                const len = Math.sqrt(vecX * vecX + vecY * vecY);
                if (len > 0.1) {
                    const nx = -vecY / len;
                    const ny = vecX / len;
                    const offsetDelta = dx * nx + dy * ny;
                    state.selectedItem.offset = (state.selectedItem.offset || 30) + offsetDelta;
                }
            }
        }
        state.dragStart = { x, y };
        draw();
    } else if (state.selectedItem) {
        const nx = snapToGrid(x - state.dragOffset.x), ny = snapToGrid(y - state.dragOffset.y);
        state.selectedItem.x = nx; state.selectedItem.y = ny;
        draw();
    }
}
 
});

canvas.addEventListener('mouseup', () => {
    if (state.isDragging) {
        // ãƒ‰ãƒ©ãƒƒã‚°çµ‚äº†æ™‚ã«ã‚°ãƒªãƒƒãƒ‰ã‚¹ãƒŠãƒƒãƒ—ã‚’é©ç”¨
        if (state.selectedItem && state.selectedItem.type === 'room') {
            const r = state.rooms.find(rm => rm.id === state.selectedItem.id);
            if (r) {
                // ã¾ãšè¾ºã‚¹ãƒŠãƒƒãƒ—ã‚’è©¦ã¿ã‚‹
                snapRoomToNearbyEdges(r);
                // ãã®å¾Œã‚°ãƒªãƒƒãƒ‰ã‚¹ãƒŠãƒƒãƒ—
                r.vertices = r.vertices.map(v => snapPointToGrid(v));
            }
            draw();
        }
        // ãƒ‰ã‚¢ãƒ»çª“ã‚’ç§»å‹•ã—ãŸå ´åˆã‚‚å±¥æ­´ä¿å­˜
        if (state.isDraggingDoorWindow) {
            saveHistory();
        } else if (state.selectedItem && state.selectedItem.type !== 'door' && state.selectedItem.type !== 'window') {
            saveHistory();
        }
    }
    state.isDragging = false;
    state.isDraggingDoorWindow = false; // ãƒ‰ã‚¢ãƒ»çª“å°‚ç”¨ãƒ•ãƒ©ã‚°ã‚’ã‚¯ãƒªã‚¢
    state.isRotating = false;
    state.isPanning = false;
    state.selectedVertex = null;
    state.selectedEdge = null;
    state.edgeNormal = null;
    state.dragStart = null;
    canvas.style.cursor = 'default';
});

// å³ã‚¯ãƒªãƒƒã‚¯ãƒ¡ãƒ‹ãƒ¥ãƒ¼ã‚’ç„¡åŠ¹åŒ–
canvas.addEventListener('contextmenu', e => {
    e.preventDefault();
});

//ãƒ„ãƒ¼ãƒ«åˆ‡ã‚Šæ›¿ãˆæ™‚ã«å¯¸æ³•ç·šã®ä¸€æ™‚çŠ¶æ…‹ã‚’ã‚¯ãƒªã‚¢
document.querySelectorAll('.tool-btn[data-tool]').forEach(b => {
    b.addEventListener('click', () => {
        document.querySelectorAll('.tool-btn[data-tool]').forEach(btn => btn.classList.remove('active'));
        b.classList.add('active');
        state.selectedTool = b.dataset.tool;
        state.selectedVertex = null;
        state.selectedEdge = null;
        state.wallStartVertex = null;
        state.tempWallEndPos = null;
        state.dimensionStart = null;
        state.tempDimensionEnd = null;
        state.polygonVertices = [];
        state.tempPolygonPos = null;

        if (state.selectedTool !== 'multi-select') {
            state.multiSelectedRooms = [];
        }

        canvas.style.cursor = state.selectedTool === 'add-vertex' ? 'crosshair' : 'default';
        draw();
    });
});

document.getElementById('wallThickness').addEventListener('input', e => { state.wallThickness = parseInt(e.target.value); });
document.getElementById('gridSize').addEventListener('input', e => { state.gridSize = parseInt(e.target.value); draw(); });
document.getElementById('toggleGrid').addEventListener('click', () => {
    state.showGrid = !state.showGrid;
    document.getElementById('toggleGrid').textContent = 'ğŸ“ ã‚°ãƒªãƒƒãƒ‰: ' + (state.showGrid ? 'ON' : 'OFF');
    draw();
});
document.getElementById('zoomIn').addEventListener('click', () => { state.zoomLevel = Math.min(state.zoomLevel + 0.1, 3.0); draw(); });
document.getElementById('zoomOut').addEventListener('click', () => { state.zoomLevel = Math.max(state.zoomLevel - 0.1, 0.3); draw(); });
document.getElementById('zoomReset').addEventListener('click', () => { state.zoomLevel = 1.0; draw(); });

document.getElementById('resetPan').addEventListener('click', () => { 
    state.panOffset = { x: 0, y: 0 };
    state.zoomLevel = 1.5;
    draw(); 
});

document.getElementById('rotateBtn').addEventListener('click', () => {
    if (!state.selectedItem) return;
    if (state.selectedItem.type === 'room') {
        const c = getPolygonCenter(state.selectedItem.vertices);
        state.selectedItem.vertices = state.selectedItem.vertices.map(v => {
            const dx = v.x - c.x, dy = v.y - c.y;
            return { x: c.x - dy, y: c.y + dx };
        });
        saveHistory();
        draw();
    } else if (state.selectedItem.rotation !== undefined) {
        state.selectedItem.rotation = (state.selectedItem.rotation + 90) % 360;
        saveHistory();
        draw();
    }
});

//deleteBtnï¼ˆå‰Šé™¤ãƒœã‚¿ãƒ³ï¼‰
document.getElementById('deleteBtn').addEventListener('click', () => {
    if (!state.selectedItem) return;
    if (state.selectedItem.type === 'room') {
        state.rooms = state.rooms.filter(r => r.id !== state.selectedItem.id);
        // éƒ¨å±‹ã«é–¢é€£ã™ã‚‹å¯¸æ³•ç·šã‚‚å‰Šé™¤
        state.dimensions = state.dimensions.filter(dim => dim.roomId !== state.selectedItem.id);
    }
    else if (state.selectedItem.type === 'wall') state.walls = state.walls.filter(w => w.id !== state.selectedItem.id);
    else if (state.selectedItem.type === 'door') state.doors = state.doors.filter(d => d.id !== state.selectedItem.id);
    else if (state.selectedItem.type === 'window') state.windows = state.windows.filter(w => w.id !== state.selectedItem.id);
    else if (state.selectedItem.type === 'manikin') state.manikins = state.manikins.filter(m => m.id !== state.selectedItem.id);
    else if (state.selectedItem.type === 'dimension') state.dimensions = state.dimensions.filter(d => d.id !== state.selectedItem.id);
    state.selectedItem = null;
    state.selectedVertex = null;
    state.selectedEdge = null;
    saveHistory();
    draw();
});

//saveBtnï¼ˆä¿å­˜ãƒœã‚¿ãƒ³ï¼‰
document.getElementById('saveBtn').addEventListener('click', () => {
    const data = { rooms: state.rooms, walls: state.walls, doors: state.doors, windows: state.windows, manikins: state.manikins, dimensions: state.dimensions };
    const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
    const a = document.createElement('a');
    a.href = URL.createObjectURL(blob);
    a.download = 'é–“å–ã‚Š_' + new Date().toISOString().slice(0, 10) + '.json';
    a.click();
});

// loadBtnï¼ˆèª­è¾¼ãƒœã‚¿ãƒ³ï¼‰
document.getElementById('loadBtn').addEventListener('click', () => { document.getElementById('fileInput').click(); });
document.getElementById('fileInput').addEventListener('change', e => {
    const f = e.target.files[0];
    if (!f) return;
    const r = new FileReader();
    r.onload = ev => {
        try {
            const d = JSON.parse(ev.target.result);
            state.rooms = d.rooms || [];
            state.walls = d.walls || [];
            state.doors = d.doors || [];
            state.windows = d.windows || [];
            state.manikins = d.manikins || [];
            state.dimensions = d.dimensions || [];
            state.selectedItem = null;
            state.selectedVertex = null;
            state.selectedEdge = null;
            draw();
            alert('èª­ã¿è¾¼ã¿å®Œäº†ï¼');
        } catch { alert('èª­ã¿è¾¼ã¿å¤±æ•—'); }
    };
    r.readAsText(f);
});

//ç”»åƒã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆæ©Ÿèƒ½ ç”»åƒä¿å­˜: æ•·åœ°ç¯„å›²ãŒè¨­å®šã•ã‚Œã¦ã„ã‚‹å ´åˆã€ãã®ç¯„å›²ã®ã¿ãŒç”»åƒã¨ã—ã¦ä¿å­˜ã•ã‚Œã¾ã™
document.getElementById('exportBtn').addEventListener('click', () => {
    console.log('ç”»åƒã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆé–‹å§‹');
    console.log('æ•·åœ°ç¯„å›²:', state.landBoundary);
    
    // ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆç¯„å›²ã‚’è¨ˆç®—ï¼ˆã™ã¹ã¦ã®è¦ç´ ã‚’å«ã‚€ï¼‰
    let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
    
    // æ•·åœ°ç¯„å›²ã‚’å«ã‚ã‚‹
    if (state.landBoundary) {
        minX = Math.min(minX, state.landBoundary.x);
        minY = Math.min(minY, state.landBoundary.y);
        maxX = Math.max(maxX, state.landBoundary.x + state.landBoundary.width);
        maxY = Math.max(maxY, state.landBoundary.y + state.landBoundary.height);
    }
    
    // éƒ¨å±‹
    state.rooms.forEach(r => {
        r.vertices.forEach(v => {
            minX = Math.min(minX, v.x);
            minY = Math.min(minY, v.y);
            maxX = Math.max(maxX, v.x);
            maxY = Math.max(maxY, v.y);
        });
    });
    
    // å£
    state.walls.forEach(w => {
        minX = Math.min(minX, w.x1, w.x2);
        minY = Math.min(minY, w.y1, w.y2);
        maxX = Math.max(maxX, w.x1, w.x2);
        maxY = Math.max(maxY, w.y1, w.y2);
    });
    
    // ãƒ‰ã‚¢ï¼ˆè¾ºä¸Šã®ä½ç½®ã‚’è¨ˆç®—ï¼‰
    state.doors.forEach(d => {
        const room = state.rooms.find(r => r.id === d.roomId);
        if (room && d.edgeIndex < room.vertices.length) {
            const v1 = room.vertices[d.edgeIndex];
            const v2 = room.vertices[(d.edgeIndex + 1) % room.vertices.length];
            const x = v1.x + d.t * (v2.x - v1.x);
            const y = v1.y + d.t * (v2.y - v1.y);
            minX = Math.min(minX, x - d.width);
            minY = Math.min(minY, y - d.width);
            maxX = Math.max(maxX, x + d.width);
            maxY = Math.max(maxY, y + d.width);
        }
    });
    
    // çª“ï¼ˆè¾ºä¸Šã®ä½ç½®ã‚’è¨ˆç®—ï¼‰
    state.windows.forEach(w => {
        const room = state.rooms.find(r => r.id === w.roomId);
        if (room && w.edgeIndex < room.vertices.length) {
            const v1 = room.vertices[w.edgeIndex];
            const v2 = room.vertices[(w.edgeIndex + 1) % room.vertices.length];
            const x = v1.x + w.t * (v2.x - v1.x);
            const y = v1.y + w.t * (v2.y - v1.y);
            minX = Math.min(minX, x - w.width);
            minY = Math.min(minY, y - 10);
            maxX = Math.max(maxX, x + w.width);
            maxY = Math.max(maxY, y + 10);
        }
    });
    
    // äººå‹
    state.manikins.forEach(m => {
        minX = Math.min(minX, m.x - 30);
        minY = Math.min(minY, m.y - 30);
        maxX = Math.max(maxX, m.x + 30);
        maxY = Math.max(maxY, m.y + 30);
    });
    
    // å¯¸æ³•ç·šï¼ˆã‚ªãƒ•ã‚»ãƒƒãƒˆã‚’è€ƒæ…®ï¼‰
    state.dimensions.forEach(dim => {
        const coords = getDimensionCoords(dim);
        if (coords) {
            const { p1, p2 } = coords;
            const offset = Math.abs(dim.offset || 30) + 50; // ä½™è£•ã‚’æŒãŸã›ã‚‹
            minX = Math.min(minX, p1.x - offset, p2.x - offset);
            minY = Math.min(minY, p1.y - offset, p2.y - offset);
            maxX = Math.max(maxX, p1.x + offset, p2.x + offset);
            maxY = Math.max(maxY, p1.y + offset, p2.y + offset);
        }
    });
    
     // ä½•ã‚‚æç”»ã•ã‚Œã¦ã„ãªã„å ´åˆã®ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ
    const margin = 50;
    let exportBounds;
    if (minX === Infinity) {
        alert('ä½•ã‚‚æç”»ã•ã‚Œã¦ã„ã¾ã›ã‚“');
        return;
    } else {
        exportBounds = {
            x: minX - margin,
            y: minY - margin,
            width: (maxX - minX) + margin * 2,
            height: (maxY - minY) + margin * 2
        };
    }
    
    console.log('ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆç¯„å›²:', exportBounds);
    console.log('éƒ¨å±‹æ•°:', state.rooms.length);
    console.log('å£æ•°:', state.walls.length);
    
// ä¸€æ™‚ã‚­ãƒ£ãƒ³ãƒã‚¹ã‚’ä½œæˆ
    const tempCanvas = document.createElement('canvas');
    const tempCtx = tempCanvas.getContext('2d');
    
    tempCanvas.width = exportBounds.width;
    tempCanvas.height = exportBounds.height;
    
    // ç™½èƒŒæ™¯
    tempCtx.fillStyle = 'white';
    tempCtx.fillRect(0, 0, tempCanvas.width, tempCanvas.height);
    
    // æç”»é ˜åŸŸã‚’èª¿æ•´
    tempCtx.save();
    tempCtx.translate(-exportBounds.x, -exportBounds.y);

    // æ•·åœ°ç¯„å›²ã®æç”»
    if (state.landBoundary) {
        tempCtx.strokeStyle = '#ff5722';
        tempCtx.lineWidth = 3;
        tempCtx.setLineDash([10, 5]);
        tempCtx.strokeRect(
            state.landBoundary.x,
            state.landBoundary.y,
            state.landBoundary.width,
            state.landBoundary.height
        );
        tempCtx.setLineDash([]);
        
        tempCtx.fillStyle = '#ff5722';
        tempCtx.font = 'bold 14px sans-serif';
        tempCtx.textAlign = 'center';
        tempCtx.fillText(
            `${(state.landBoundary.width / state.scale).toFixed(1)}m Ã— ${(state.landBoundary.height / state.scale).toFixed(1)}m`,
            state.landBoundary.x + state.landBoundary.width / 2,
            state.landBoundary.y - 10
        );
    }

    // éƒ¨å±‹ã®æç”»
    state.rooms.forEach(r => {
        tempCtx.fillStyle = r.color || '#e3f2fd';
        tempCtx.beginPath();
        tempCtx.moveTo(r.vertices[0].x, r.vertices[0].y);
        for (let i = 1; i < r.vertices.length; i++) tempCtx.lineTo(r.vertices[i].x, r.vertices[i].y);
        tempCtx.closePath();
        tempCtx.fill();
        
        tempCtx.strokeStyle = '#666';
        tempCtx.lineWidth = 1;
        tempCtx.stroke();

        const c = getPolygonCenter(r.vertices);
        tempCtx.fillStyle = '#333';
        tempCtx.font = 'bold 16px sans-serif';
        tempCtx.textAlign = 'center';
        tempCtx.fillText(r.name || 'éƒ¨å±‹', c.x, c.y - 15);
        tempCtx.font = '14px sans-serif';
        tempCtx.fillText(calculateTatamiFromArea(calculatePolygonArea(r.vertices)) + 'ç•³', c.x, c.y + 5);
        if (r.purpose) {
            tempCtx.font = '12px sans-serif';
            tempCtx.fillStyle = '#666';
            tempCtx.fillText(r.purpose, c.x, c.y + 22);
        }
    });

    // å£ã®æç”»
    state.walls.forEach(w => {
        tempCtx.strokeStyle = '#333';
        tempCtx.lineWidth = w.thickness;
        tempCtx.lineCap = 'square';
        tempCtx.beginPath();
        tempCtx.moveTo(w.x1, w.y1);
        tempCtx.lineTo(w.x2, w.y2);
        tempCtx.stroke();
    });

    // ãƒ‰ã‚¢ã®æç”»
    state.doors.forEach(d => {
        const room = state.rooms.find(r => r.id === d.roomId);
        if (!room) return;
        
        const v1 = room.vertices[d.edgeIndex];
        const v2 = room.vertices[(d.edgeIndex + 1) % room.vertices.length];
        const dx = v2.x - v1.x;
        const dy = v2.y - v1.y;
        
        const x = v1.x + d.t * dx;
        const y = v1.y + d.t * dy;
        const angle = Math.atan2(dy, dx);
        
        tempCtx.save();
        tempCtx.translate(x, y);
        tempCtx.rotate(angle);
        
        if (d.doorType === 'swing') {
            tempCtx.strokeStyle = '#8b4513';
            tempCtx.lineWidth = 4;
            
            if (d.flippedHorizontal) {
                tempCtx.scale(-1, 1);
                tempCtx.translate(-d.width, 0);
            }
            
            tempCtx.beginPath();
            tempCtx.moveTo(0, 0);
            tempCtx.lineTo(d.width, 0);
            tempCtx.stroke();
            
            tempCtx.strokeStyle = '#ccc';
            tempCtx.lineWidth = 1;
            tempCtx.beginPath();
            if (d.flipped) {
                tempCtx.arc(0, 0, d.width, -Math.PI/2, 0);
            } else {
                tempCtx.arc(0, 0, d.width, 0, Math.PI/2);
            }
            tempCtx.stroke();
        } else {
            tempCtx.strokeStyle = '#8b4513';
            tempCtx.lineWidth = 4;
            tempCtx.beginPath();
            tempCtx.moveTo(0, -5);
            tempCtx.lineTo(d.width/2, -5);
            tempCtx.moveTo(d.width/2, 5);
            tempCtx.lineTo(d.width, 5);
            tempCtx.stroke();
        }
        tempCtx.restore();
    });

    // çª“ã®æç”»
    state.windows.forEach(w => {
        const room = state.rooms.find(r => r.id === w.roomId);
        if (!room) return;
        
        const v1 = room.vertices[w.edgeIndex];
        const v2 = room.vertices[(w.edgeIndex + 1) % room.vertices.length];
        const dx = v2.x - v1.x;
        const dy = v2.y - v1.y;
        
        const x = v1.x + w.t * dx;
        const y = v1.y + w.t * dy;
        const angle = Math.atan2(dy, dx);
        
        tempCtx.save();
        tempCtx.translate(x, y);
        tempCtx.rotate(angle);
        tempCtx.strokeStyle = '#4fc3f7';
        tempCtx.lineWidth = 5;
        tempCtx.beginPath();
        tempCtx.moveTo(0, 0);
        tempCtx.lineTo(w.width, 0);
        tempCtx.stroke();
        tempCtx.strokeStyle = '#b3e5fc';
        tempCtx.lineWidth = 2;
        tempCtx.beginPath();
        tempCtx.moveTo(w.width/2, -4);
        tempCtx.lineTo(w.width/2, 4);
        tempCtx.stroke();
        tempCtx.restore();
    });

    // äººå‹ã®æç”»
    state.manikins.forEach(m => {
        tempCtx.save();
        tempCtx.translate(m.x, m.y);
        tempCtx.rotate((m.rotation * Math.PI) / 180);
        const s = 20;
        tempCtx.strokeStyle = '#ff5722';
        tempCtx.fillStyle = '#ffccbc';
        tempCtx.lineWidth = 2;
        tempCtx.beginPath();
        tempCtx.arc(0, -s, s/3, 0, Math.PI * 2);
        tempCtx.fill();
        tempCtx.stroke();
        tempCtx.beginPath();
        tempCtx.moveTo(0, -s * 0.7);
        tempCtx.lineTo(0, s * 0.5);
        tempCtx.stroke();
        tempCtx.beginPath();
        tempCtx.moveTo(-s/2, -s * 0.3);
        tempCtx.lineTo(0, -s * 0.5);
        tempCtx.lineTo(s/2, -s * 0.3);
        tempCtx.stroke();
        tempCtx.beginPath();
        tempCtx.moveTo(0, s * 0.5);
        tempCtx.lineTo(-s/3, s * 1.2);
        tempCtx.moveTo(0, s * 0.5);
        tempCtx.lineTo(s/3, s * 1.2);
        tempCtx.stroke();
        tempCtx.restore();
    });

    // å¯¸æ³•ç·šã®æç”»
    state.dimensions.forEach(dim => {
        const coords = getDimensionCoords(dim);
        if (!coords) return;
        
        const { p1, p2 } = coords;
        const dx = p2.x - p1.x;
        const dy = p2.y - p1.y;
        const length = Math.sqrt(dx * dx + dy * dy);
        
        if (length < 0.1) return;
        
        const angle = Math.atan2(dy, dx);
        const offsetDist = dim.offset || 30;
        const nx = -dy / length;
        const ny = dx / length;
        
        const ox1 = p1.x + nx * offsetDist;
        const oy1 = p1.y + ny * offsetDist;
        const ox2 = p2.x + nx * offsetDist;
        const oy2 = p2.y + ny * offsetDist;
        
        tempCtx.strokeStyle = '#666';
        tempCtx.lineWidth = 1;
        
        tempCtx.setLineDash([3, 3]);
        tempCtx.beginPath();
        tempCtx.moveTo(p1.x, p1.y);
        tempCtx.lineTo(ox1, oy1);
        tempCtx.stroke();
        tempCtx.beginPath();
        tempCtx.moveTo(p2.x, p2.y);
        tempCtx.lineTo(ox2, oy2);
        tempCtx.stroke();
        tempCtx.setLineDash([]);
        
        tempCtx.lineWidth = 1.5;
        tempCtx.beginPath();
        tempCtx.moveTo(ox1, oy1);
        tempCtx.lineTo(ox2, oy2);
        tempCtx.stroke();
        
        const arrowSize = 6;
        tempCtx.beginPath();
        tempCtx.moveTo(ox1, oy1);
        tempCtx.lineTo(ox1 + arrowSize * Math.cos(angle + Math.PI * 0.85), oy1 + arrowSize * Math.sin(angle + Math.PI * 0.85));
        tempCtx.moveTo(ox1, oy1);
        tempCtx.lineTo(ox1 + arrowSize * Math.cos(angle - Math.PI * 0.85), oy1 + arrowSize * Math.sin(angle - Math.PI * 0.85));
        tempCtx.stroke();
        
        tempCtx.beginPath();
        tempCtx.moveTo(ox2, oy2);
        tempCtx.lineTo(ox2 - arrowSize * Math.cos(angle + Math.PI * 0.85), oy2 - arrowSize * Math.sin(angle + Math.PI * 0.85));
        tempCtx.moveTo(ox2, oy2);
        tempCtx.lineTo(ox2 - arrowSize * Math.cos(angle - Math.PI * 0.85), oy2 - arrowSize * Math.sin(angle - Math.PI * 0.85));
        tempCtx.stroke();
        
        const mx = (ox1 + ox2) / 2;
        const my = (oy1 + oy2) / 2;
        
        tempCtx.save();
        tempCtx.translate(mx, my);
        tempCtx.rotate(angle);
        
        const text = formatLength(length);
        tempCtx.font = 'bold 12px sans-serif';
        tempCtx.textAlign = 'center';
        tempCtx.textBaseline = 'middle';
        const metrics = tempCtx.measureText(text);
        const padding = 3;
        
        tempCtx.fillStyle = 'white';
        tempCtx.fillRect(-metrics.width / 2 - padding, -7, metrics.width + padding * 2, 14);
        
        tempCtx.fillStyle = '#333';
        tempCtx.fillText(text, 0, 0);
        
        tempCtx.restore();
    });
    
    tempCtx.restore();
    
    // ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰
    const a = document.createElement('a');
    a.download = 'é–“å–ã‚Š_' + new Date().toISOString().slice(0, 10) + '.png';
    a.href = tempCanvas.toDataURL();
    a.click();
});

// æ•·åœ°ç¯„å›²è¨­å®šãƒœã‚¿ãƒ³
document.getElementById('setLandBtn').addEventListener('click', () => {
    const width = parseFloat(document.getElementById('landWidth').value);
    const depth = parseFloat(document.getElementById('landDepth').value);
    
    if (width && depth && width > 0 && depth > 0) {
        const margin = 50;
        state.landBoundary = {
            x: margin,
            y: margin,
            width: width * state.scale,
            height: depth * state.scale
        };
        console.log('æ•·åœ°ç¯„å›²ã‚’è¨­å®š:', state.landBoundary);
        saveHistory();
        draw();
    } else {
        alert('æ­£ã—ã„æ•°å€¤ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„');
    }
});

// æ•·åœ°ç¯„å›²æ¶ˆå»ãƒœã‚¿ãƒ³
document.getElementById('clearLandBtn').addEventListener('click', () => {
    state.landBoundary = null;
    saveHistory();
    draw();
});

//clearBtnï¼ˆã‚¯ãƒªã‚¢ãƒœã‚¿ãƒ³ï¼‰
document.getElementById('clearBtn').addEventListener('click', () => {
    if (confirm('ã™ã¹ã¦å‰Šé™¤ã—ã¾ã™ã‹?')) {
        state.rooms = []; state.walls = []; state.doors = []; state.windows = []; state.manikins = []; state.dimensions = [];
        state.selectedItem = null; state.selectedVertex = null; state.selectedEdge = null;
        saveHistory();
        draw();
    }
});

// ã‚¿ãƒƒãƒã‚¤ãƒ™ãƒ³ãƒˆå¯¾å¿œ
let lastTouchEnd = 0;

canvas.addEventListener('touchstart', e => {
    if (e.touches.length === 1) {
        e.preventDefault();
        const touch = e.touches[0];
        
        const rect = canvas.getBoundingClientRect();
        const x = ((touch.clientX - rect.left) - state.panOffset.x) / state.zoomLevel;
        const y = ((touch.clientY - rect.top) - state.panOffset.y) / state.zoomLevel;
        
        // ã‚¢ã‚¤ãƒ†ãƒ ãŒãªã„å ´æ‰€ãªã‚‰ãƒ‘ãƒ³é–‹å§‹
        const f = findItemAt(x, y);
        if (!f && state.selectedTool === 'select') {
            state.isPanning = true;
            state.dragStart = { x: touch.clientX, y: touch.clientY };
        } else {
            const mouseEvent = new MouseEvent('mousedown', {
                clientX: touch.clientX,
                clientY: touch.clientY,
                bubbles: true
            });
            canvas.dispatchEvent(mouseEvent);
        }
    }
}, { passive: false });

canvas.addEventListener('touchmove', e => {
    e.preventDefault();
    if (e.touches.length === 1) {
        const touch = e.touches[0];
        
        // ãƒ‘ãƒ³ä¸­ã®å ´åˆã¯ç›´æ¥ãƒ‘ãƒ³å‡¦ç†ã‚’å®Ÿè¡Œ
        if (state.isPanning) {
            const dx = touch.clientX - state.dragStart.x;
            const dy = touch.clientY - state.dragStart.y;
            state.panOffset.x += dx;
            state.panOffset.y += dy;
            state.dragStart = { x: touch.clientX, y: touch.clientY };
            draw();
        } else {
            const mouseEvent = new MouseEvent('mousemove', {
                clientX: touch.clientX,
                clientY: touch.clientY,
                bubbles: true
            });
            canvas.dispatchEvent(mouseEvent);
        }
    }
}, { passive: false });

canvas.addEventListener('touchend', e => {
    e.preventDefault();
    const now = Date.now();
    if (now - lastTouchEnd <= 300) {
        // ãƒ€ãƒ–ãƒ«ã‚¿ãƒƒãƒ—ã§ã‚ºãƒ¼ãƒ ãƒªã‚»ãƒƒãƒˆ
        state.zoomLevel = 1.0;
        draw();
    }
    lastTouchEnd = now;
    
    const mouseEvent = new MouseEvent('mouseup', {
        bubbles: true
    });
    canvas.dispatchEvent(mouseEvent);
}, { passive: false });

// ãƒ”ãƒ³ãƒã‚ºãƒ¼ãƒ å¯¾å¿œ
let lastDistance = 0;
canvas.addEventListener('touchstart', e => {
    if (e.touches.length === 2) {
        const dx = e.touches[0].clientX - e.touches[1].clientX;
        const dy = e.touches[0].clientY - e.touches[1].clientY;
        lastDistance = Math.sqrt(dx * dx + dy * dy);
    }
}, { passive: true });

canvas.addEventListener('touchmove', e => {
    if (e.touches.length === 2) {
        e.preventDefault();
        const dx = e.touches[0].clientX - e.touches[1].clientX;
        const dy = e.touches[0].clientY - e.touches[1].clientY;
        const distance = Math.sqrt(dx * dx + dy * dy);
        
        if (lastDistance > 0) {
            const delta = distance - lastDistance;
            state.zoomLevel = Math.max(0.3, Math.min(3.0, state.zoomLevel + delta * 0.01));
            draw();
        }
        lastDistance = distance;
    }
}, { passive: false });

// å…ƒã«æˆ»ã™ãƒ»ã‚„ã‚Šç›´ã—ãƒœã‚¿ãƒ³
document.getElementById('undoBtn').addEventListener('click', undo);
document.getElementById('redoBtn').addEventListener('click', redo);

// å®¶å…·ã‚«ãƒ†ã‚´ãƒªå¤‰æ›´
document.getElementById('furnitureCategory').addEventListener('change', e => {
    displayFurnitureList(e.target.value);
});

// ã‚«ã‚¹ã‚¿ãƒ å®¶å…·ä½œæˆ
document.getElementById('addCustomFurniture').addEventListener('click', () => {
    const name = prompt('å®¶å…·åã‚’å…¥åŠ›ã—ã¦ãã ã•ã„:', 'æ–°ã—ã„å®¶å…·');
    if (!name) return;
    
    const width = parseFloat(prompt('å¹…ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„ (cm):', '100'));
    const depth = parseFloat(prompt('å¥¥è¡Œãã‚’å…¥åŠ›ã—ã¦ãã ã•ã„ (cm):', '60'));
    
    if (!width || !depth) return;
    
    const item = { name, width, depth, color: '#e0e0e0', icon: 'ğŸ“¦' };
    const category = document.getElementById('furnitureCategory').value;
    
    furnitureLibrary[category].push(item);
    displayFurnitureList(category);
    
    // ã™ãã«è¿½åŠ 
    addFurniture(category, furnitureLibrary[category].length - 1);
});

// åˆæœŸè¡¨ç¤º
displayFurnitureList('kitchen');

// åˆæˆãƒœã‚¿ãƒ³ã®å‡¦ç†ã‚’é–¢æ•°åŒ–
function handleUnion() {
    if (state.multiSelectedRooms.length < 2) {
        alert('2ã¤ä»¥ä¸Šã®éƒ¨å±‹ã‚’é¸æŠã—ã¦ãã ã•ã„');
        return;
    }
    
    const selectedRooms = state.rooms.filter(r => state.multiSelectedRooms.includes(r.id));
    const newRoom = unionPolygons(selectedRooms);
    
    if (newRoom) {
        state.rooms = state.rooms.filter(r => !state.multiSelectedRooms.includes(r.id));
        state.dimensions = state.dimensions.filter(dim => !state.multiSelectedRooms.includes(dim.roomId));
        state.rooms.push(newRoom);
        
        state.multiSelectedRooms = [];
        state.selectedItem = newRoom;
        saveHistory();
        draw();
    }
}

// æ¸›ç®—ãƒœã‚¿ãƒ³ã®å‡¦ç†ã‚’é–¢æ•°åŒ–
function handleSubtract() {
    if (state.multiSelectedRooms.length < 2) {
        alert('2ã¤ä»¥ä¸Šã®éƒ¨å±‹ã‚’é¸æŠã—ã¦ãã ã•ã„ï¼ˆæœ€åˆãŒåŸºæº–ã€æ®‹ã‚Šã‚’å¼•ãã¾ã™ï¼‰');
        return;
    }
    
    const baseRoom = state.rooms.find(r => r.id === state.multiSelectedRooms[0]);
    const subtractRooms = state.rooms.filter(r => state.multiSelectedRooms.slice(1).includes(r.id));
    
    const result = subtractPolygons(baseRoom, subtractRooms);
    
    if (result) {
        state.rooms = state.rooms.filter(r => !state.multiSelectedRooms.includes(r.id));
        state.dimensions = state.dimensions.filter(dim => !state.multiSelectedRooms.includes(dim.roomId));
        state.rooms.push(result);
        
        state.multiSelectedRooms = [];
        state.selectedItem = result;
        saveHistory();
        draw();
    }
}

// é¸æŠè§£é™¤ã®å‡¦ç†ã‚’é–¢æ•°åŒ–
function handleClearSelection() {
    state.multiSelectedRooms = [];
    draw();
}

// ã‚¯ã‚¤ãƒƒã‚¯ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ãƒœã‚¿ãƒ³ã®ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼
document.getElementById('unionBtnQuick').addEventListener('click', handleUnion);
document.getElementById('subtractBtnQuick').addEventListener('click', handleSubtract);
document.getElementById('clearSelectionBtnQuick').addEventListener('click', handleClearSelection);

document.addEventListener('keydown', e => {
    if (e.key === 'Delete' && state.selectedItem) document.getElementById('deleteBtn').click();
    else if (e.key === 'r' && state.selectedItem) document.getElementById('rotateBtn').click();
    else if ((e.ctrlKey || e.metaKey) && e.key === 'z' && !e.shiftKey) {
        e.preventDefault();
        undo();
    } else if ((e.ctrlKey || e.metaKey) && (e.key === 'y' || (e.key === 'z' && e.shiftKey))) {
        e.preventDefault();
        redo();
    }
});

// åˆæœŸå±¥æ­´ã‚’ä¿å­˜
saveHistory();
draw();

// ãƒšãƒ¼ã‚¸é›¢è„±æ™‚ãƒ»ãƒãƒƒã‚¯ã‚°ãƒ©ã‚¦ãƒ³ãƒ‰ç§»è¡Œæ™‚ã®è‡ªå‹•ä¿å­˜
window.addEventListener('beforeunload', () => {
    autoSave();
});

window.addEventListener('pagehide', () => {
    autoSave();
});

window.addEventListener('visibilitychange', () => {
    if (document.visibilityState === 'hidden') {
        autoSave();
    }
});

// å®šæœŸçš„ãªè‡ªå‹•ä¿å­˜ï¼ˆ30ç§’ã”ã¨ï¼‰
setInterval(() => {
    autoSave();
}, 30000);
    </script>
</body>
</html>
